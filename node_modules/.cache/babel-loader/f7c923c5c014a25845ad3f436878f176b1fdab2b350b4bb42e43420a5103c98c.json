{"ast":null,"code":"// src/Context.tsx\nimport { createContext, useContext, useMemo } from \"react\";\n\n// src/EditorContent.tsx\nimport React, { forwardRef } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar mergeRefs = (...refs) => {\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === \"function\") {\n        ref(node);\n      } else if (ref) {\n        ;\n        ref.current = node;\n      }\n    });\n  };\n};\nvar Portals = ({\n  contentComponent\n}) => {\n  const renderers = useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);\n  return /* @__PURE__ */jsx(Fragment, {\n    children: Object.values(renderers)\n  });\n};\nfunction getInstance() {\n  const subscribers = /* @__PURE__ */new Set();\n  let renderers = {};\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    },\n    getSnapshot() {\n      return renderers;\n    },\n    getServerSnapshot() {\n      return renderers;\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id, renderer) {\n      renderers = {\n        ...renderers,\n        [id]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id)\n      };\n      subscribers.forEach(subscriber => subscriber());\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id) {\n      const nextRenderers = {\n        ...renderers\n      };\n      delete nextRenderers[id];\n      renderers = nextRenderers;\n      subscribers.forEach(subscriber => subscriber());\n    }\n  };\n}\nvar PureEditorContent = class extends React.Component {\n  constructor(props) {\n    var _a;\n    super(props);\n    this.editorContentRef = React.createRef();\n    this.initialized = false;\n    this.state = {\n      hasContentComponentInitialized: Boolean((_a = props.editor) == null ? void 0 : _a.contentComponent)\n    };\n  }\n  componentDidMount() {\n    this.init();\n  }\n  componentDidUpdate() {\n    this.init();\n  }\n  init() {\n    const editor = this.props.editor;\n    if (editor && !editor.isDestroyed && editor.options.element) {\n      if (editor.contentComponent) {\n        return;\n      }\n      const element = this.editorContentRef.current;\n      element.append(...editor.options.element.childNodes);\n      editor.setOptions({\n        element\n      });\n      editor.contentComponent = getInstance();\n      if (!this.state.hasContentComponentInitialized) {\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState(prevState => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true\n              };\n            }\n            return prevState;\n          });\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n          }\n        });\n      }\n      editor.createNodeViews();\n      this.initialized = true;\n    }\n  }\n  componentWillUnmount() {\n    var _a;\n    const editor = this.props.editor;\n    if (!editor) {\n      return;\n    }\n    this.initialized = false;\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {}\n      });\n    }\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent();\n    }\n    editor.contentComponent = null;\n    if (!((_a = editor.options.element) == null ? void 0 : _a.firstChild)) {\n      return;\n    }\n    const newElement = document.createElement(\"div\");\n    newElement.append(...editor.options.element.childNodes);\n    editor.setOptions({\n      element: newElement\n    });\n  }\n  render() {\n    const {\n      editor,\n      innerRef,\n      ...rest\n    } = this.props;\n    return /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(\"div\", {\n        ref: mergeRefs(innerRef, this.editorContentRef),\n        ...rest\n      }), (editor == null ? void 0 : editor.contentComponent) && /* @__PURE__ */jsx(Portals, {\n        contentComponent: editor.contentComponent\n      })]\n    });\n  }\n};\nvar EditorContentWithKey = forwardRef((props, ref) => {\n  const key = React.useMemo(() => {\n    return Math.floor(Math.random() * 4294967295).toString();\n  }, [props.editor]);\n  return React.createElement(PureEditorContent, {\n    key,\n    innerRef: ref,\n    ...props\n  });\n});\nvar EditorContent = React.memo(EditorContentWithKey);\n\n// src/useEditor.ts\nimport { Editor } from \"@tiptap/core\";\nimport { useDebugValue as useDebugValue2, useEffect as useEffect2, useRef, useState as useState2 } from \"react\";\nimport { useSyncExternalStore as useSyncExternalStore2 } from \"use-sync-external-store/shim/index.js\";\n\n// src/useEditorState.ts\nimport deepEqual from \"fast-deep-equal/es6/react.js\";\nimport { useDebugValue, useEffect, useLayoutEffect, useState } from \"react\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\nvar EditorStateManager = class {\n  constructor(initialEditor) {\n    this.transactionNumber = 0;\n    this.lastTransactionNumber = 0;\n    this.subscribers = /* @__PURE__ */new Set();\n    this.editor = initialEditor;\n    this.lastSnapshot = {\n      editor: initialEditor,\n      transactionNumber: 0\n    };\n    this.getSnapshot = this.getSnapshot.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.watch = this.watch.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot() {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot;\n    }\n    this.lastTransactionNumber = this.transactionNumber;\n    this.lastSnapshot = {\n      editor: this.editor,\n      transactionNumber: this.transactionNumber\n    };\n    return this.lastSnapshot;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return {\n      editor: null,\n      transactionNumber: 0\n    };\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback) {\n    this.subscribers.add(callback);\n    return () => {\n      this.subscribers.delete(callback);\n    };\n  }\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor) {\n    this.editor = nextEditor;\n    if (this.editor) {\n      const fn = () => {\n        this.transactionNumber += 1;\n        this.subscribers.forEach(callback => callback());\n      };\n      const currentEditor = this.editor;\n      currentEditor.on(\"transaction\", fn);\n      return () => {\n        currentEditor.off(\"transaction\", fn);\n      };\n    }\n    return void 0;\n  }\n};\nfunction useEditorState(options) {\n  var _a;\n  const [editorStateManager] = useState(() => new EditorStateManager(options.editor));\n  const selectedState = useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) != null ? _a : deepEqual);\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor);\n  }, [options.editor, editorStateManager]);\n  useDebugValue(selectedState);\n  return selectedState;\n}\n\n// src/useEditor.ts\nvar isDev = process.env.NODE_ENV !== \"production\";\nvar isSSR = typeof window === \"undefined\";\nvar isNext = isSSR || Boolean(typeof window !== \"undefined\" && window.next);\nvar EditorInstanceManager = class _EditorInstanceManager {\n  constructor(options) {\n    /**\n     * The current editor instance.\n     */\n    this.editor = null;\n    /**\n     * The subscriptions to notify when the editor instance\n     * has been created or destroyed.\n     */\n    this.subscriptions = /* @__PURE__ */new Set();\n    /**\n     * Whether the editor has been mounted.\n     */\n    this.isComponentMounted = false;\n    /**\n     * The most recent dependencies array.\n     */\n    this.previousDeps = null;\n    /**\n     * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n     */\n    this.instanceId = \"\";\n    this.options = options;\n    this.subscriptions = /* @__PURE__ */new Set();\n    this.setEditor(this.getInitialEditor());\n    this.scheduleDestroy();\n    this.getEditor = this.getEditor.bind(this);\n    this.getServerSnapshot = this.getServerSnapshot.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n    this.scheduleDestroy = this.scheduleDestroy.bind(this);\n    this.onRender = this.onRender.bind(this);\n    this.createEditor = this.createEditor.bind(this);\n  }\n  setEditor(editor) {\n    this.editor = editor;\n    this.instanceId = Math.random().toString(36).slice(2, 9);\n    this.subscriptions.forEach(cb => cb());\n  }\n  getInitialEditor() {\n    if (this.options.current.immediatelyRender === void 0) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          throw new Error(\"Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.\");\n        }\n        return null;\n      }\n      return this.createEditor();\n    }\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      throw new Error(\"Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.\");\n    }\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor();\n    }\n    return null;\n  }\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  createEditor() {\n    const optionsToApply = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBeforeCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onBlur: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onBlur) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onCreate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onCreate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDestroy: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDestroy) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onFocus: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onFocus) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onSelectionUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onSelectionUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onTransaction: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onTransaction) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onUpdate: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onUpdate) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onContentError: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onContentError) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDrop: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDrop) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onPaste: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onPaste) == null ? void 0 : _b.call(_a, ...args);\n      },\n      onDelete: (...args) => {\n        var _a, _b;\n        return (_b = (_a = this.options.current).onDelete) == null ? void 0 : _b.call(_a, ...args);\n      }\n    };\n    const editor = new Editor(optionsToApply);\n    return editor;\n  }\n  /**\n   * Get the current editor instance.\n   */\n  getEditor() {\n    return this.editor;\n  }\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot() {\n    return null;\n  }\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange) {\n    this.subscriptions.add(onStoreChange);\n    return () => {\n      this.subscriptions.delete(onStoreChange);\n    };\n  }\n  static compareOptions(a, b) {\n    return Object.keys(a).every(key => {\n      if ([\"onCreate\", \"onBeforeCreate\", \"onDestroy\", \"onUpdate\", \"onTransaction\", \"onFocus\", \"onBlur\", \"onSelectionUpdate\", \"onContentError\", \"onDrop\", \"onPaste\"].includes(key)) {\n        return true;\n      }\n      if (key === \"extensions\" && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false;\n        }\n        return a.extensions.every((extension, index) => {\n          var _a;\n          if (extension !== ((_a = b.extensions) == null ? void 0 : _a[index])) {\n            return false;\n          }\n          return true;\n        });\n      }\n      if (a[key] !== b[key]) {\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps) {\n    return () => {\n      this.isComponentMounted = true;\n      clearTimeout(this.scheduledDestructionTimeout);\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        if (!_EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable\n          });\n        }\n      } else {\n        this.refreshEditorInstance(deps);\n      }\n      return () => {\n        this.isComponentMounted = false;\n        this.scheduleDestroy();\n      };\n    };\n  }\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  refreshEditorInstance(deps) {\n    if (this.editor && !this.editor.isDestroyed) {\n      if (this.previousDeps === null) {\n        this.previousDeps = deps;\n        return;\n      }\n      const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index]);\n      if (depsAreEqual) {\n        return;\n      }\n    }\n    if (this.editor && !this.editor.isDestroyed) {\n      this.editor.destroy();\n    }\n    this.setEditor(this.createEditor());\n    this.previousDeps = deps;\n  }\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  scheduleDestroy() {\n    const currentInstanceId = this.instanceId;\n    const currentEditor = this.editor;\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        if (currentEditor) {\n          currentEditor.setOptions(this.options.current);\n        }\n        return;\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy();\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null);\n        }\n      }\n    }, 1);\n  }\n};\nfunction useEditor(options = {}, deps = []) {\n  const mostRecentOptions = useRef(options);\n  mostRecentOptions.current = options;\n  const [instanceManager] = useState2(() => new EditorInstanceManager(mostRecentOptions));\n  const editor = useSyncExternalStore2(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n  useDebugValue2(editor);\n  useEffect2(instanceManager.onRender(deps));\n  useEditorState({\n    editor,\n    selector: ({\n      transactionNumber\n    }) => {\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === void 0) {\n        return null;\n      }\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0;\n      }\n      return transactionNumber + 1;\n    }\n  });\n  return editor;\n}\n\n// src/Context.tsx\nimport { jsx as jsx2, jsxs as jsxs2 } from \"react/jsx-runtime\";\nvar EditorContext = createContext({\n  editor: null\n});\nvar EditorConsumer = EditorContext.Consumer;\nvar useCurrentEditor = () => useContext(EditorContext);\nfunction EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}) {\n  const editor = useEditor(editorOptions);\n  const contextValue = useMemo(() => ({\n    editor\n  }), [editor]);\n  if (!editor) {\n    return null;\n  }\n  return /* @__PURE__ */jsxs2(EditorContext.Provider, {\n    value: contextValue,\n    children: [slotBefore, /* @__PURE__ */jsx2(EditorConsumer, {\n      children: ({\n        editor: currentEditor\n      }) => /* @__PURE__ */jsx2(EditorContent, {\n        editor: currentEditor,\n        ...editorContainerProps\n      })\n    }), children, slotAfter]\n  });\n}\n\n// src/useReactNodeView.ts\nimport { createContext as createContext2, createElement, useContext as useContext2 } from \"react\";\nvar ReactNodeViewContext = createContext2({\n  onDragStart: () => {},\n  nodeViewContentChildren: void 0,\n  nodeViewContentRef: () => {}\n});\nvar ReactNodeViewContentProvider = ({\n  children,\n  content\n}) => {\n  return createElement(ReactNodeViewContext.Provider, {\n    value: {\n      nodeViewContentChildren: content\n    }\n  }, children);\n};\nvar useReactNodeView = () => useContext2(ReactNodeViewContext);\n\n// src/NodeViewContent.tsx\nimport { jsx as jsx3 } from \"react/jsx-runtime\";\nfunction NodeViewContent({\n  as: Tag = \"div\",\n  ...props\n}) {\n  const {\n    nodeViewContentRef,\n    nodeViewContentChildren\n  } = useReactNodeView();\n  return (\n    // @ts-ignore\n    /* @__PURE__ */\n    jsx3(Tag, {\n      ...props,\n      ref: nodeViewContentRef,\n      \"data-node-view-content\": \"\",\n      style: {\n        whiteSpace: \"pre-wrap\",\n        ...props.style\n      },\n      children: nodeViewContentChildren\n    })\n  );\n}\n\n// src/NodeViewWrapper.tsx\nimport React3 from \"react\";\nimport { jsx as jsx4 } from \"react/jsx-runtime\";\nvar NodeViewWrapper = React3.forwardRef((props, ref) => {\n  const {\n    onDragStart\n  } = useReactNodeView();\n  const Tag = props.as || \"div\";\n  return (\n    // @ts-ignore\n    /* @__PURE__ */\n    jsx4(Tag, {\n      ...props,\n      ref,\n      \"data-node-view-wrapper\": \"\",\n      onDragStart,\n      style: {\n        whiteSpace: \"normal\",\n        ...props.style\n      }\n    })\n  );\n});\n\n// src/ReactMarkViewRenderer.tsx\nimport { MarkView } from \"@tiptap/core\";\nimport React4 from \"react\";\n\n// src/ReactRenderer.tsx\nimport { version as reactVersion } from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { jsx as jsx5 } from \"react/jsx-runtime\";\nfunction isClassComponent(Component) {\n  return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\nfunction isForwardRefComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.forward_ref)\" || Component.$$typeof.description === \"react.forward_ref\"));\n}\nfunction isMemoComponent(Component) {\n  return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.memo)\" || Component.$$typeof.description === \"react.memo\"));\n}\nfunction canReceiveRef(Component) {\n  if (isClassComponent(Component)) {\n    return true;\n  }\n  if (isForwardRefComponent(Component)) {\n    return true;\n  }\n  if (isMemoComponent(Component)) {\n    const wrappedComponent = Component.type;\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n    }\n  }\n  return false;\n}\nfunction isReact19Plus() {\n  try {\n    if (reactVersion) {\n      const majorVersion = parseInt(reactVersion.split(\".\")[0], 10);\n      return majorVersion >= 19;\n    }\n  } catch {}\n  return false;\n}\nvar ReactRenderer = class {\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(component, {\n    editor,\n    props = {},\n    as = \"div\",\n    className = \"\"\n  }) {\n    this.ref = null;\n    this.id = Math.floor(Math.random() * 4294967295).toString();\n    this.component = component;\n    this.editor = editor;\n    this.props = props;\n    this.element = document.createElement(as);\n    this.element.classList.add(\"react-renderer\");\n    if (className) {\n      this.element.classList.add(...className.split(\" \"));\n    }\n    if (this.editor.isInitialized) {\n      flushSync(() => {\n        this.render();\n      });\n    } else {\n      queueMicrotask(() => {\n        this.render();\n      });\n    }\n  }\n  /**\n   * Render the React component.\n   */\n  render() {\n    var _a;\n    const Component = this.component;\n    const props = this.props;\n    const editor = this.editor;\n    const isReact19 = isReact19Plus();\n    const componentCanReceiveRef = canReceiveRef(Component);\n    const elementProps = {\n      ...props\n    };\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref;\n    }\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      elementProps.ref = ref => {\n        this.ref = ref;\n      };\n    }\n    this.reactElement = /* @__PURE__ */jsx5(Component, {\n      ...elementProps\n    });\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.setRenderer(this.id, this);\n  }\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props = {}) {\n    this.props = {\n      ...this.props,\n      ...props\n    };\n    this.render();\n  }\n  /**\n   * Destroy the React component.\n   */\n  destroy() {\n    var _a;\n    const editor = this.editor;\n    (_a = editor == null ? void 0 : editor.contentComponent) == null ? void 0 : _a.removeRenderer(this.id);\n  }\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes) {\n    Object.keys(attributes).forEach(key => {\n      this.element.setAttribute(key, attributes[key]);\n    });\n  }\n};\n\n// src/ReactMarkViewRenderer.tsx\nimport { jsx as jsx6 } from \"react/jsx-runtime\";\nvar ReactMarkViewContext = React4.createContext({\n  markViewContentRef: () => {}\n});\nvar MarkViewContent = props => {\n  const {\n    as: Tag = \"span\",\n    ...rest\n  } = props;\n  const {\n    markViewContentRef\n  } = React4.useContext(ReactMarkViewContext);\n  return (\n    // @ts-ignore\n    /* @__PURE__ */\n    jsx6(Tag, {\n      ...rest,\n      ref: markViewContentRef,\n      \"data-mark-view-content\": \"\"\n    })\n  );\n};\nvar ReactMarkView = class extends MarkView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    this.didMountContentDomElement = false;\n    const {\n      as = \"span\",\n      attrs,\n      className = \"\"\n    } = options || {};\n    const componentProps = {\n      ...props,\n      updateAttributes: this.updateAttributes.bind(this)\n    };\n    this.contentDOMElement = document.createElement(\"span\");\n    const markViewContentRef = el => {\n      if (el && this.contentDOMElement && el.firstChild !== this.contentDOMElement) {\n        el.appendChild(this.contentDOMElement);\n        this.didMountContentDomElement = true;\n      }\n    };\n    const context = {\n      markViewContentRef\n    };\n    const ReactMarkViewProvider = React4.memo(componentProps2 => {\n      return /* @__PURE__ */jsx6(ReactMarkViewContext.Provider, {\n        value: context,\n        children: React4.createElement(component, componentProps2)\n      });\n    });\n    ReactMarkViewProvider.displayName = \"ReactNodeView\";\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim()\n    });\n    if (attrs) {\n      this.renderer.updateAttributes(attrs);\n    }\n  }\n  get dom() {\n    return this.renderer.element;\n  }\n  get contentDOM() {\n    if (!this.didMountContentDomElement) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n};\nfunction ReactMarkViewRenderer(component, options = {}) {\n  return props => new ReactMarkView(component, props, options);\n}\n\n// src/ReactNodeViewRenderer.tsx\nimport { getRenderedAttributes, NodeView } from \"@tiptap/core\";\nimport { createElement as createElement2, createRef, memo } from \"react\";\nimport { jsx as jsx7 } from \"react/jsx-runtime\";\nvar ReactNodeView = class extends NodeView {\n  constructor(component, props, options) {\n    super(component, props, options);\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n      }\n      this.contentDOMElement.dataset.nodeViewContentReact = \"\";\n      this.contentDOMElement.dataset.nodeViewWrapper = \"\";\n      this.contentDOMElement.style.whiteSpace = \"inherit\";\n      const contentTarget = this.dom.querySelector(\"[data-node-view-content]\");\n      if (!contentTarget) {\n        return;\n      }\n      contentTarget.appendChild(this.contentDOMElement);\n    }\n  }\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations,\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extension,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: createRef()\n    };\n    if (!this.component.displayName) {\n      const capitalizeFirstChar = string => {\n        return string.charAt(0).toUpperCase() + string.substring(1);\n      };\n      this.component.displayName = capitalizeFirstChar(this.extension.name);\n    }\n    const onDragStart = this.onDragStart.bind(this);\n    const nodeViewContentRef = element => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        if (element.hasAttribute(\"data-node-view-wrapper\")) {\n          element.removeAttribute(\"data-node-view-wrapper\");\n        }\n        element.appendChild(this.contentDOMElement);\n      }\n    };\n    const context = {\n      onDragStart,\n      nodeViewContentRef\n    };\n    const Component = this.component;\n    const ReactNodeViewProvider = memo(componentProps => {\n      return /* @__PURE__ */jsx7(ReactNodeViewContext.Provider, {\n        value: context,\n        children: createElement2(Component, componentProps)\n      });\n    });\n    ReactNodeViewProvider.displayName = \"ReactNodeView\";\n    let as = this.node.isInline ? \"span\" : \"div\";\n    if (this.options.as) {\n      as = this.options.as;\n    }\n    const {\n      className = \"\"\n    } = this.options;\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim()\n    });\n    this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.updateElementAttributes();\n  }\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    var _a;\n    if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) == null ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n      throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n    }\n    return this.renderer.element;\n  }\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null;\n    }\n    return this.contentDOMElement;\n  }\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    const {\n      from,\n      to\n    } = this.editor.state.selection;\n    const pos = this.getPos();\n    if (typeof pos !== \"number\") {\n      return;\n    }\n    if (from <= pos && to >= pos + this.node.nodeSize) {\n      if (this.renderer.props.selected) {\n        return;\n      }\n      this.selectNode();\n    } else {\n      if (!this.renderer.props.selected) {\n        return;\n      }\n      this.deselectNode();\n    }\n  }\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node, decorations, innerDecorations) {\n    const rerenderComponent = props => {\n      this.renderer.updateProps(props);\n      if (typeof this.options.attrs === \"function\") {\n        this.updateElementAttributes();\n      }\n    };\n    if (node.type !== this.node.type) {\n      return false;\n    }\n    if (typeof this.options.update === \"function\") {\n      const oldNode = this.node;\n      const oldDecorations = this.decorations;\n      const oldInnerDecorations = this.innerDecorations;\n      this.node = node;\n      this.decorations = decorations;\n      this.innerDecorations = innerDecorations;\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () => rerenderComponent({\n          node,\n          decorations,\n          innerDecorations\n        })\n      });\n    }\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true;\n    }\n    this.node = node;\n    this.decorations = decorations;\n    this.innerDecorations = innerDecorations;\n    rerenderComponent({\n      node,\n      decorations,\n      innerDecorations\n    });\n    return true;\n  }\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true\n    });\n    this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false\n    });\n    this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n  }\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy();\n    this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n    this.contentDOMElement = null;\n  }\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj = {};\n      if (typeof this.options.attrs === \"function\") {\n        const extensionAttributes = this.editor.extensionManager.attributes;\n        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes);\n        attrsObj = this.options.attrs({\n          node: this.node,\n          HTMLAttributes\n        });\n      } else {\n        attrsObj = this.options.attrs;\n      }\n      this.renderer.updateAttributes(attrsObj);\n    }\n  }\n};\nfunction ReactNodeViewRenderer(component, options) {\n  return props => {\n    if (!props.editor.contentComponent) {\n      return {};\n    }\n    return new ReactNodeView(component, props, options);\n  };\n}\n\n// src/index.ts\nexport * from \"@tiptap/core\";\nexport { EditorConsumer, EditorContent, EditorContext, EditorProvider, MarkViewContent, NodeViewContent, NodeViewWrapper, PureEditorContent, ReactMarkView, ReactMarkViewContext, ReactMarkViewRenderer, ReactNodeView, ReactNodeViewContentProvider, ReactNodeViewContext, ReactNodeViewRenderer, ReactRenderer, useCurrentEditor, useEditor, useEditorState, useReactNodeView };","map":{"version":3,"names":["createContext","useContext","useMemo","React","forwardRef","ReactDOM","useSyncExternalStore","Fragment","jsx","jsxs","mergeRefs","refs","node","forEach","ref","current","Portals","contentComponent","renderers","subscribe","getSnapshot","getServerSnapshot","children","Object","values","getInstance","subscribers","Set","callback","add","delete","setRenderer","id","renderer","createPortal","reactElement","element","subscriber","removeRenderer","nextRenderers","PureEditorContent","Component","constructor","props","_a","editorContentRef","createRef","initialized","state","hasContentComponentInitialized","Boolean","editor","componentDidMount","init","componentDidUpdate","isDestroyed","options","append","childNodes","setOptions","unsubscribeToContentComponent","setState","prevState","createNodeViews","componentWillUnmount","view","setProps","nodeViews","firstChild","newElement","document","createElement","render","innerRef","rest","EditorContentWithKey","key","Math","floor","random","toString","EditorContent","memo","Editor","useDebugValue","useDebugValue2","useEffect","useEffect2","useRef","useState","useState2","useSyncExternalStore2","deepEqual","useLayoutEffect","useSyncExternalStoreWithSelector","useIsomorphicLayoutEffect","window","EditorStateManager","initialEditor","transactionNumber","lastTransactionNumber","lastSnapshot","bind","watch","nextEditor","fn","currentEditor","on","off","useEditorState","editorStateManager","selectedState","selector","equalityFn","isDev","process","env","NODE_ENV","isSSR","isNext","next","EditorInstanceManager","_EditorInstanceManager","subscriptions","isComponentMounted","previousDeps","instanceId","setEditor","getInitialEditor","scheduleDestroy","getEditor","refreshEditorInstance","onRender","createEditor","slice","cb","immediatelyRender","Error","optionsToApply","onBeforeCreate","args","_b","call","onBlur","onCreate","onDestroy","onFocus","onSelectionUpdate","onTransaction","onUpdate","onContentError","onDrop","onPaste","onDelete","onStoreChange","compareOptions","a","b","keys","every","includes","extensions","length","extension","index","deps","clearTimeout","scheduledDestructionTimeout","editable","isEditable","depsAreEqual","dep","destroy","currentInstanceId","setTimeout","useEditor","mostRecentOptions","instanceManager","shouldRerenderOnTransaction","jsx2","jsxs2","EditorContext","EditorConsumer","Consumer","useCurrentEditor","EditorProvider","slotAfter","slotBefore","editorContainerProps","editorOptions","contextValue","Provider","value","createContext2","useContext2","ReactNodeViewContext","onDragStart","nodeViewContentChildren","nodeViewContentRef","ReactNodeViewContentProvider","content","useReactNodeView","jsx3","NodeViewContent","as","Tag","style","whiteSpace","React3","jsx4","NodeViewWrapper","MarkView","React4","version","reactVersion","flushSync","jsx5","isClassComponent","prototype","isReactComponent","isForwardRefComponent","$$typeof","description","isMemoComponent","canReceiveRef","wrappedComponent","type","isReact19Plus","majorVersion","parseInt","split","ReactRenderer","component","className","classList","isInitialized","queueMicrotask","isReact19","componentCanReceiveRef","elementProps","updateProps","updateAttributes","attributes","setAttribute","jsx6","ReactMarkViewContext","markViewContentRef","MarkViewContent","ReactMarkView","didMountContentDomElement","attrs","componentProps","contentDOMElement","el","appendChild","context","ReactMarkViewProvider","componentProps2","displayName","mark","name","trim","dom","contentDOM","ReactMarkViewRenderer","getRenderedAttributes","NodeView","createElement2","jsx7","ReactNodeView","isLeaf","contentDOMElementTag","isInline","dataset","nodeViewContentReact","nodeViewWrapper","contentTarget","querySelector","mount","decorations","innerDecorations","selected","HTMLAttributes","getPos","deleteNode","capitalizeFirstChar","string","charAt","toUpperCase","substring","hasAttribute","removeAttribute","ReactNodeViewProvider","handleSelectionUpdate","updateElementAttributes","firstElementChild","from","to","selection","pos","nodeSize","selectNode","deselectNode","update","rerenderComponent","oldNode","oldDecorations","oldInnerDecorations","newNode","newDecorations","remove","attrsObj","extensionAttributes","extensionManager","ReactNodeViewRenderer"],"sources":["C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\Context.tsx","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\EditorContent.tsx","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\useEditor.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\useEditorState.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\useReactNodeView.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\NodeViewContent.tsx","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\NodeViewWrapper.tsx","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\ReactMarkViewRenderer.tsx","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\ReactRenderer.tsx","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\ReactNodeViewRenderer.tsx","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\react\\src\\index.ts"],"sourcesContent":["import type { Editor } from '@tiptap/core'\nimport type { HTMLAttributes, ReactNode } from 'react'\nimport React, { createContext, useContext, useMemo } from 'react'\n\nimport { EditorContent } from './EditorContent.js'\nimport type { UseEditorOptions } from './useEditor.js'\nimport { useEditor } from './useEditor.js'\n\nexport type EditorContextValue = {\n  editor: Editor | null\n}\n\nexport const EditorContext = createContext<EditorContextValue>({\n  editor: null,\n})\n\nexport const EditorConsumer = EditorContext.Consumer\n\n/**\n * A hook to get the current editor instance.\n */\nexport const useCurrentEditor = () => useContext(EditorContext)\n\nexport type EditorProviderProps = {\n  children?: ReactNode\n  slotBefore?: ReactNode\n  slotAfter?: ReactNode\n  editorContainerProps?: HTMLAttributes<HTMLDivElement>\n} & UseEditorOptions\n\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */\nexport function EditorProvider({\n  children,\n  slotAfter,\n  slotBefore,\n  editorContainerProps = {},\n  ...editorOptions\n}: EditorProviderProps) {\n  const editor = useEditor(editorOptions)\n  const contextValue = useMemo(() => ({ editor }), [editor])\n\n  if (!editor) {\n    return null\n  }\n\n  return (\n    <EditorContext.Provider value={contextValue}>\n      {slotBefore}\n      <EditorConsumer>\n        {({ editor: currentEditor }) => <EditorContent editor={currentEditor} {...editorContainerProps} />}\n      </EditorConsumer>\n      {children}\n      {slotAfter}\n    </EditorContext.Provider>\n  )\n}\n","import type { Editor } from '@tiptap/core'\nimport type { ForwardedRef, HTMLProps, LegacyRef, MutableRefObject } from 'react'\nimport React, { forwardRef } from 'react'\nimport ReactDOM from 'react-dom'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js'\n\nimport type { ContentComponent, EditorWithContentComponent } from './Editor.js'\nimport type { ReactRenderer } from './ReactRenderer.js'\n\nconst mergeRefs = <T extends HTMLDivElement>(...refs: Array<MutableRefObject<T> | LegacyRef<T> | undefined>) => {\n  return (node: T) => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node)\n      } else if (ref) {\n        ;(ref as MutableRefObject<T | null>).current = node\n      }\n    })\n  }\n}\n\n/**\n * This component renders all of the editor's node views.\n */\nconst Portals: React.FC<{ contentComponent: ContentComponent }> = ({ contentComponent }) => {\n  // For performance reasons, we render the node view portals on state changes only\n  const renderers = useSyncExternalStore(\n    contentComponent.subscribe,\n    contentComponent.getSnapshot,\n    contentComponent.getServerSnapshot,\n  )\n\n  // This allows us to directly render the portals without any additional wrapper\n  return <>{Object.values(renderers)}</>\n}\n\nexport interface EditorContentProps extends HTMLProps<HTMLDivElement> {\n  editor: Editor | null\n  innerRef?: ForwardedRef<HTMLDivElement | null>\n}\n\nfunction getInstance(): ContentComponent {\n  const subscribers = new Set<() => void>()\n  let renderers: Record<string, React.ReactPortal> = {}\n\n  return {\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback: () => void) {\n      subscribers.add(callback)\n      return () => {\n        subscribers.delete(callback)\n      }\n    },\n    getSnapshot() {\n      return renderers\n    },\n    getServerSnapshot() {\n      return renderers\n    },\n    /**\n     * Adds a new NodeView Renderer to the editor.\n     */\n    setRenderer(id: string, renderer: ReactRenderer) {\n      renderers = {\n        ...renderers,\n        [id]: ReactDOM.createPortal(renderer.reactElement, renderer.element, id),\n      }\n\n      subscribers.forEach(subscriber => subscriber())\n    },\n    /**\n     * Removes a NodeView Renderer from the editor.\n     */\n    removeRenderer(id: string) {\n      const nextRenderers = { ...renderers }\n\n      delete nextRenderers[id]\n      renderers = nextRenderers\n      subscribers.forEach(subscriber => subscriber())\n    },\n  }\n}\n\nexport class PureEditorContent extends React.Component<\n  EditorContentProps,\n  { hasContentComponentInitialized: boolean }\n> {\n  editorContentRef: React.RefObject<any>\n\n  initialized: boolean\n\n  unsubscribeToContentComponent?: () => void\n\n  constructor(props: EditorContentProps) {\n    super(props)\n    this.editorContentRef = React.createRef()\n    this.initialized = false\n\n    this.state = {\n      hasContentComponentInitialized: Boolean((props.editor as EditorWithContentComponent | null)?.contentComponent),\n    }\n  }\n\n  componentDidMount() {\n    this.init()\n  }\n\n  componentDidUpdate() {\n    this.init()\n  }\n\n  init() {\n    const editor = this.props.editor as EditorWithContentComponent | null\n\n    if (editor && !editor.isDestroyed && editor.options.element) {\n      if (editor.contentComponent) {\n        return\n      }\n\n      const element = this.editorContentRef.current\n\n      element.append(...editor.options.element.childNodes)\n\n      editor.setOptions({\n        element,\n      })\n\n      editor.contentComponent = getInstance()\n\n      // Has the content component been initialized?\n      if (!this.state.hasContentComponentInitialized) {\n        // Subscribe to the content component\n        this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n          this.setState(prevState => {\n            if (!prevState.hasContentComponentInitialized) {\n              return {\n                hasContentComponentInitialized: true,\n              }\n            }\n            return prevState\n          })\n\n          // Unsubscribe to previous content component\n          if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent()\n          }\n        })\n      }\n\n      editor.createNodeViews()\n\n      this.initialized = true\n    }\n  }\n\n  componentWillUnmount() {\n    const editor = this.props.editor as EditorWithContentComponent | null\n\n    if (!editor) {\n      return\n    }\n\n    this.initialized = false\n\n    if (!editor.isDestroyed) {\n      editor.view.setProps({\n        nodeViews: {},\n      })\n    }\n\n    if (this.unsubscribeToContentComponent) {\n      this.unsubscribeToContentComponent()\n    }\n\n    editor.contentComponent = null\n\n    if (!editor.options.element?.firstChild) {\n      return\n    }\n\n    // TODO using the new editor.mount method might allow us to remove this\n    const newElement = document.createElement('div')\n\n    newElement.append(...editor.options.element.childNodes)\n\n    editor.setOptions({\n      element: newElement,\n    })\n  }\n\n  render() {\n    const { editor, innerRef, ...rest } = this.props\n\n    return (\n      <>\n        <div ref={mergeRefs(innerRef, this.editorContentRef)} {...rest} />\n        {/* @ts-ignore */}\n        {editor?.contentComponent && <Portals contentComponent={editor.contentComponent} />}\n      </>\n    )\n  }\n}\n\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = forwardRef<HTMLDivElement, EditorContentProps>(\n  (props: Omit<EditorContentProps, 'innerRef'>, ref) => {\n    const key = React.useMemo(() => {\n      return Math.floor(Math.random() * 0xffffffff).toString()\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [props.editor])\n\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return React.createElement(PureEditorContent, {\n      key,\n      innerRef: ref,\n      ...props,\n    })\n  },\n)\n\nexport const EditorContent = React.memo(EditorContentWithKey)\n","import { type EditorOptions, Editor } from '@tiptap/core'\nimport type { DependencyList, MutableRefObject } from 'react'\nimport { useDebugValue, useEffect, useRef, useState } from 'react'\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js'\n\nimport { useEditorState } from './useEditorState.js'\n\n// @ts-ignore\nconst isDev = process.env.NODE_ENV !== 'production'\nconst isSSR = typeof window === 'undefined'\nconst isNext = isSSR || Boolean(typeof window !== 'undefined' && (window as any).next)\n\n/**\n * The options for the `useEditor` hook.\n */\nexport type UseEditorOptions = Partial<EditorOptions> & {\n  /**\n   * Whether to render the editor on the first render.\n   * If client-side rendering, set this to `true`.\n   * If server-side rendering, set this to `false`.\n   * @default true\n   */\n  immediatelyRender?: boolean\n  /**\n   * Whether to re-render the editor on each transaction.\n   * This is legacy behavior that will be removed in future versions.\n   * @default false\n   */\n  shouldRerenderOnTransaction?: boolean\n}\n\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */\nclass EditorInstanceManager {\n  /**\n   * The current editor instance.\n   */\n  private editor: Editor | null = null\n\n  /**\n   * The most recent options to apply to the editor.\n   */\n  private options: MutableRefObject<UseEditorOptions>\n\n  /**\n   * The subscriptions to notify when the editor instance\n   * has been created or destroyed.\n   */\n  private subscriptions = new Set<() => void>()\n\n  /**\n   * A timeout to destroy the editor if it was not mounted within a time frame.\n   */\n  private scheduledDestructionTimeout: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * Whether the editor has been mounted.\n   */\n  private isComponentMounted = false\n\n  /**\n   * The most recent dependencies array.\n   */\n  private previousDeps: DependencyList | null = null\n\n  /**\n   * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n   */\n  public instanceId = ''\n\n  constructor(options: MutableRefObject<UseEditorOptions>) {\n    this.options = options\n    this.subscriptions = new Set<() => void>()\n    this.setEditor(this.getInitialEditor())\n    this.scheduleDestroy()\n\n    this.getEditor = this.getEditor.bind(this)\n    this.getServerSnapshot = this.getServerSnapshot.bind(this)\n    this.subscribe = this.subscribe.bind(this)\n    this.refreshEditorInstance = this.refreshEditorInstance.bind(this)\n    this.scheduleDestroy = this.scheduleDestroy.bind(this)\n    this.onRender = this.onRender.bind(this)\n    this.createEditor = this.createEditor.bind(this)\n  }\n\n  private setEditor(editor: Editor | null) {\n    this.editor = editor\n    this.instanceId = Math.random().toString(36).slice(2, 9)\n\n    // Notify all subscribers that the editor instance has been created\n    this.subscriptions.forEach(cb => cb())\n  }\n\n  private getInitialEditor() {\n    if (this.options.current.immediatelyRender === undefined) {\n      if (isSSR || isNext) {\n        if (isDev) {\n          /**\n           * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n           * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n           */\n          throw new Error(\n            'Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.',\n          )\n        }\n\n        // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n        return null\n      }\n\n      // Default to immediately rendering when client-side rendering\n      return this.createEditor()\n    }\n\n    if (this.options.current.immediatelyRender && isSSR && isDev) {\n      // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n      throw new Error(\n        'Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.',\n      )\n    }\n\n    if (this.options.current.immediatelyRender) {\n      return this.createEditor()\n    }\n\n    return null\n  }\n\n  /**\n   * Create a new editor instance. And attach event listeners.\n   */\n  private createEditor(): Editor {\n    const optionsToApply: Partial<EditorOptions> = {\n      ...this.options.current,\n      // Always call the most recent version of the callback function by default\n      onBeforeCreate: (...args) => this.options.current.onBeforeCreate?.(...args),\n      onBlur: (...args) => this.options.current.onBlur?.(...args),\n      onCreate: (...args) => this.options.current.onCreate?.(...args),\n      onDestroy: (...args) => this.options.current.onDestroy?.(...args),\n      onFocus: (...args) => this.options.current.onFocus?.(...args),\n      onSelectionUpdate: (...args) => this.options.current.onSelectionUpdate?.(...args),\n      onTransaction: (...args) => this.options.current.onTransaction?.(...args),\n      onUpdate: (...args) => this.options.current.onUpdate?.(...args),\n      onContentError: (...args) => this.options.current.onContentError?.(...args),\n      onDrop: (...args) => this.options.current.onDrop?.(...args),\n      onPaste: (...args) => this.options.current.onPaste?.(...args),\n      onDelete: (...args) => this.options.current.onDelete?.(...args),\n    }\n    const editor = new Editor(optionsToApply)\n\n    // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n\n    return editor\n  }\n\n  /**\n   * Get the current editor instance.\n   */\n  getEditor(): Editor | null {\n    return this.editor\n  }\n\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot(): null {\n    return null\n  }\n\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(onStoreChange: () => void) {\n    this.subscriptions.add(onStoreChange)\n\n    return () => {\n      this.subscriptions.delete(onStoreChange)\n    }\n  }\n\n  static compareOptions(a: UseEditorOptions, b: UseEditorOptions) {\n    return (Object.keys(a) as (keyof UseEditorOptions)[]).every(key => {\n      if (\n        [\n          'onCreate',\n          'onBeforeCreate',\n          'onDestroy',\n          'onUpdate',\n          'onTransaction',\n          'onFocus',\n          'onBlur',\n          'onSelectionUpdate',\n          'onContentError',\n          'onDrop',\n          'onPaste',\n        ].includes(key)\n      ) {\n        // we don't want to compare callbacks, they are always different and only registered once\n        return true\n      }\n\n      // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n      if (key === 'extensions' && a.extensions && b.extensions) {\n        if (a.extensions.length !== b.extensions.length) {\n          return false\n        }\n        return a.extensions.every((extension, index) => {\n          if (extension !== b.extensions?.[index]) {\n            return false\n          }\n          return true\n        })\n      }\n      if (a[key] !== b[key]) {\n        // if any of the options have changed, we should update the editor options\n        return false\n      }\n      return true\n    })\n  }\n\n  /**\n   * On each render, we will create, update, or destroy the editor instance.\n   * @param deps The dependencies to watch for changes\n   * @returns A cleanup function\n   */\n  onRender(deps: DependencyList) {\n    // The returned callback will run on each render\n    return () => {\n      this.isComponentMounted = true\n      // Cleanup any scheduled destructions, since we are currently rendering\n      clearTimeout(this.scheduledDestructionTimeout)\n\n      if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n        // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n        if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n          // But, the options are different, so we need to update the editor options\n          // Still, this is faster than re-creating the editor\n          this.editor.setOptions({\n            ...this.options.current,\n            editable: this.editor.isEditable,\n          })\n        }\n      } else {\n        // When the editor:\n        // - does not yet exist\n        // - is destroyed\n        // - the deps array changes\n        // We need to destroy the editor instance and re-initialize it\n        this.refreshEditorInstance(deps)\n      }\n\n      return () => {\n        this.isComponentMounted = false\n        this.scheduleDestroy()\n      }\n    }\n  }\n\n  /**\n   * Recreate the editor instance if the dependencies have changed.\n   */\n  private refreshEditorInstance(deps: DependencyList) {\n    if (this.editor && !this.editor.isDestroyed) {\n      // Editor instance already exists\n      if (this.previousDeps === null) {\n        // If lastDeps has not yet been initialized, reuse the current editor instance\n        this.previousDeps = deps\n        return\n      }\n      const depsAreEqual =\n        this.previousDeps.length === deps.length && this.previousDeps.every((dep, index) => dep === deps[index])\n\n      if (depsAreEqual) {\n        // deps exist and are equal, no need to recreate\n        return\n      }\n    }\n\n    if (this.editor && !this.editor.isDestroyed) {\n      // Destroy the editor instance if it exists\n      this.editor.destroy()\n    }\n\n    this.setEditor(this.createEditor())\n\n    // Update the lastDeps to the current deps\n    this.previousDeps = deps\n  }\n\n  /**\n   * Schedule the destruction of the editor instance.\n   * This will only destroy the editor if it was not mounted on the next tick.\n   * This is to avoid destroying the editor instance when it's actually still mounted.\n   */\n  private scheduleDestroy() {\n    const currentInstanceId = this.instanceId\n    const currentEditor = this.editor\n\n    // Wait two ticks to see if the component is still mounted\n    this.scheduledDestructionTimeout = setTimeout(() => {\n      if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n        // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n        if (currentEditor) {\n          // just re-apply options as they might have changed\n          currentEditor.setOptions(this.options.current)\n        }\n        return\n      }\n      if (currentEditor && !currentEditor.isDestroyed) {\n        currentEditor.destroy()\n        if (this.instanceId === currentInstanceId) {\n          this.setEditor(null)\n        }\n      }\n      // This allows the effect to run again between ticks\n      // which may save us from having to re-create the editor\n    }, 1)\n  }\n}\n\n/**\n * This hook allows you to create an editor instance.\n * @param options The editor options\n * @param deps The dependencies to watch for changes\n * @returns The editor instance\n * @example const editor = useEditor({ extensions: [...] })\n */\nexport function useEditor(\n  options: UseEditorOptions & { immediatelyRender: false },\n  deps?: DependencyList,\n): Editor | null\n\n/**\n * This hook allows you to create an editor instance.\n * @param options The editor options\n * @param deps The dependencies to watch for changes\n * @returns The editor instance\n * @example const editor = useEditor({ extensions: [...] })\n */\nexport function useEditor(options: UseEditorOptions, deps?: DependencyList): Editor\n\nexport function useEditor(options: UseEditorOptions = {}, deps: DependencyList = []): Editor | null {\n  const mostRecentOptions = useRef(options)\n\n  mostRecentOptions.current = options\n\n  const [instanceManager] = useState(() => new EditorInstanceManager(mostRecentOptions))\n\n  const editor = useSyncExternalStore(\n    instanceManager.subscribe,\n    instanceManager.getEditor,\n    instanceManager.getServerSnapshot,\n  )\n\n  useDebugValue(editor)\n\n  // This effect will handle creating/updating the editor instance\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(instanceManager.onRender(deps))\n\n  // The default behavior is to re-render on each transaction\n  // This is legacy behavior that will be removed in future versions\n  useEditorState({\n    editor,\n    selector: ({ transactionNumber }) => {\n      if (options.shouldRerenderOnTransaction === false || options.shouldRerenderOnTransaction === undefined) {\n        // This will prevent the editor from re-rendering on each transaction\n        return null\n      }\n\n      // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n      if (options.immediatelyRender && transactionNumber === 0) {\n        return 0\n      }\n      return transactionNumber + 1\n    },\n  })\n\n  return editor\n}\n","import type { Editor } from '@tiptap/core'\nimport deepEqual from 'fast-deep-equal/es6/react.js'\nimport { useDebugValue, useEffect, useLayoutEffect, useState } from 'react'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect\n\nexport type EditorStateSnapshot<TEditor extends Editor | null = Editor | null> = {\n  editor: TEditor\n  transactionNumber: number\n}\n\nexport type UseEditorStateOptions<TSelectorResult, TEditor extends Editor | null = Editor | null> = {\n  /**\n   * The editor instance.\n   */\n  editor: TEditor\n  /**\n   * A selector function to determine the value to compare for re-rendering.\n   */\n  selector: (context: EditorStateSnapshot<TEditor>) => TSelectorResult\n  /**\n   * A custom equality function to determine if the editor should re-render.\n   * @default `deepEqual` from `fast-deep-equal`\n   */\n  equalityFn?: (a: TSelectorResult, b: TSelectorResult | null) => boolean\n}\n\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */\nclass EditorStateManager<TEditor extends Editor | null = Editor | null> {\n  private transactionNumber = 0\n\n  private lastTransactionNumber = 0\n\n  private lastSnapshot: EditorStateSnapshot<TEditor>\n\n  private editor: TEditor\n\n  private subscribers = new Set<() => void>()\n\n  constructor(initialEditor: TEditor) {\n    this.editor = initialEditor\n    this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 }\n\n    this.getSnapshot = this.getSnapshot.bind(this)\n    this.getServerSnapshot = this.getServerSnapshot.bind(this)\n    this.watch = this.watch.bind(this)\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  /**\n   * Get the current editor instance.\n   */\n  getSnapshot(): EditorStateSnapshot<TEditor> {\n    if (this.transactionNumber === this.lastTransactionNumber) {\n      return this.lastSnapshot\n    }\n    this.lastTransactionNumber = this.transactionNumber\n    this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }\n    return this.lastSnapshot\n  }\n\n  /**\n   * Always disable the editor on the server-side.\n   */\n  getServerSnapshot(): EditorStateSnapshot<null> {\n    return { editor: null, transactionNumber: 0 }\n  }\n\n  /**\n   * Subscribe to the editor instance's changes.\n   */\n  subscribe(callback: () => void): () => void {\n    this.subscribers.add(callback)\n    return () => {\n      this.subscribers.delete(callback)\n    }\n  }\n\n  /**\n   * Watch the editor instance for changes.\n   */\n  watch(nextEditor: Editor | null): undefined | (() => void) {\n    this.editor = nextEditor as TEditor\n\n    if (this.editor) {\n      /**\n       * This will force a re-render when the editor state changes.\n       * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n       * This could be more efficient, but it's a good trade-off for now.\n       */\n      const fn = () => {\n        this.transactionNumber += 1\n        this.subscribers.forEach(callback => callback())\n      }\n\n      const currentEditor = this.editor\n\n      currentEditor.on('transaction', fn)\n      return () => {\n        currentEditor.off('transaction', fn)\n      }\n    }\n\n    return undefined\n  }\n}\n\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor>,\n): TSelectorResult\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor | null>,\n): TSelectorResult | null\n\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nexport function useEditorState<TSelectorResult>(\n  options: UseEditorStateOptions<TSelectorResult, Editor> | UseEditorStateOptions<TSelectorResult, Editor | null>,\n): TSelectorResult | null {\n  const [editorStateManager] = useState(() => new EditorStateManager(options.editor))\n\n  // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n  const selectedState = useSyncExternalStoreWithSelector(\n    editorStateManager.subscribe,\n    editorStateManager.getSnapshot,\n    editorStateManager.getServerSnapshot,\n    options.selector as UseEditorStateOptions<TSelectorResult, Editor | null>['selector'],\n    options.equalityFn ?? deepEqual,\n  )\n\n  useIsomorphicLayoutEffect(() => {\n    return editorStateManager.watch(options.editor)\n  }, [options.editor, editorStateManager])\n\n  useDebugValue(selectedState)\n\n  return selectedState\n}\n","import type { ReactNode } from 'react'\nimport { createContext, createElement, useContext } from 'react'\n\nexport interface ReactNodeViewContextProps {\n  onDragStart?: (event: DragEvent) => void\n  nodeViewContentRef?: (element: HTMLElement | null) => void\n  /**\n   * This allows you to add children into the NodeViewContent component.\n   * This is useful when statically rendering the content of a node view.\n   */\n  nodeViewContentChildren?: ReactNode\n}\n\nexport const ReactNodeViewContext = createContext<ReactNodeViewContextProps>({\n  onDragStart: () => {\n    // no-op\n  },\n  nodeViewContentChildren: undefined,\n  nodeViewContentRef: () => {\n    // no-op\n  },\n})\n\nexport const ReactNodeViewContentProvider = ({ children, content }: { children: ReactNode; content: ReactNode }) => {\n  return createElement(ReactNodeViewContext.Provider, { value: { nodeViewContentChildren: content } }, children)\n}\n\nexport const useReactNodeView = () => useContext(ReactNodeViewContext)\n","import type { ComponentProps } from 'react'\nimport React from 'react'\n\nimport { useReactNodeView } from './useReactNodeView.js'\n\nexport type NodeViewContentProps<T extends keyof React.JSX.IntrinsicElements = 'div'> = {\n  as?: NoInfer<T>\n} & ComponentProps<T>\n\nexport function NodeViewContent<T extends keyof React.JSX.IntrinsicElements = 'div'>({\n  as: Tag = 'div' as T,\n  ...props\n}: NodeViewContentProps<T>) {\n  const { nodeViewContentRef, nodeViewContentChildren } = useReactNodeView()\n\n  return (\n    // @ts-ignore\n    <Tag\n      {...props}\n      ref={nodeViewContentRef}\n      data-node-view-content=\"\"\n      style={{\n        whiteSpace: 'pre-wrap',\n        ...props.style,\n      }}\n    >\n      {nodeViewContentChildren}\n    </Tag>\n  )\n}\n","import React from 'react'\n\nimport { useReactNodeView } from './useReactNodeView.js'\n\nexport interface NodeViewWrapperProps {\n  [key: string]: any\n  as?: React.ElementType\n}\n\nexport const NodeViewWrapper: React.FC<NodeViewWrapperProps> = React.forwardRef((props, ref) => {\n  const { onDragStart } = useReactNodeView()\n  const Tag = props.as || 'div'\n\n  return (\n    // @ts-ignore\n    <Tag\n      {...props}\n      ref={ref}\n      data-node-view-wrapper=\"\"\n      onDragStart={onDragStart}\n      style={{\n        whiteSpace: 'normal',\n        ...props.style,\n      }}\n    />\n  )\n})\n","/* eslint-disable @typescript-eslint/no-shadow */\nimport type { MarkViewProps, MarkViewRenderer, MarkViewRendererOptions } from '@tiptap/core'\nimport { MarkView } from '@tiptap/core'\nimport React from 'react'\n\n// import { flushSync } from 'react-dom'\nimport { ReactRenderer } from './ReactRenderer.js'\n\nexport interface MarkViewContextProps {\n  markViewContentRef: (element: HTMLElement | null) => void\n}\nexport const ReactMarkViewContext = React.createContext<MarkViewContextProps>({\n  markViewContentRef: () => {\n    // do nothing\n  },\n})\n\nexport type MarkViewContentProps<T extends keyof React.JSX.IntrinsicElements = 'span'> = {\n  as?: T\n} & Omit<React.ComponentProps<T>, 'as'>\n\nexport const MarkViewContent = <T extends keyof React.JSX.IntrinsicElements = 'span'>(\n  props: MarkViewContentProps<T>,\n) => {\n  const { as: Tag = 'span', ...rest } = props\n  const { markViewContentRef } = React.useContext(ReactMarkViewContext)\n\n  return (\n    // @ts-ignore\n    <Tag {...rest} ref={markViewContentRef} data-mark-view-content=\"\" />\n  )\n}\n\nexport interface ReactMarkViewRendererOptions extends MarkViewRendererOptions {\n  /**\n   * The tag name of the element wrapping the React component.\n   */\n  as?: string\n  className?: string\n  attrs?: { [key: string]: string }\n}\n\nexport class ReactMarkView extends MarkView<React.ComponentType<MarkViewProps>, ReactMarkViewRendererOptions> {\n  renderer: ReactRenderer\n  contentDOMElement: HTMLElement | null\n  didMountContentDomElement = false\n\n  constructor(\n    component: React.ComponentType<MarkViewProps>,\n    props: MarkViewProps,\n    options?: Partial<ReactMarkViewRendererOptions>,\n  ) {\n    super(component, props, options)\n\n    const { as = 'span', attrs, className = '' } = options || {}\n    const componentProps = { ...props, updateAttributes: this.updateAttributes.bind(this) } satisfies MarkViewProps\n\n    this.contentDOMElement = document.createElement('span')\n\n    const markViewContentRef: MarkViewContextProps['markViewContentRef'] = el => {\n      if (el && this.contentDOMElement && el.firstChild !== this.contentDOMElement) {\n        el.appendChild(this.contentDOMElement)\n        this.didMountContentDomElement = true\n      }\n    }\n    const context: MarkViewContextProps = {\n      markViewContentRef,\n    }\n\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactMarkViewProvider: React.FunctionComponent<MarkViewProps> = React.memo(componentProps => {\n      return (\n        <ReactMarkViewContext.Provider value={context}>\n          {React.createElement(component, componentProps)}\n        </ReactMarkViewContext.Provider>\n      )\n    })\n\n    ReactMarkViewProvider.displayName = 'ReactNodeView'\n\n    this.renderer = new ReactRenderer(ReactMarkViewProvider, {\n      editor: props.editor,\n      props: componentProps,\n      as,\n      className: `mark-${props.mark.type.name} ${className}`.trim(),\n    })\n\n    if (attrs) {\n      this.renderer.updateAttributes(attrs)\n    }\n  }\n\n  get dom() {\n    return this.renderer.element as HTMLElement\n  }\n\n  get contentDOM() {\n    if (!this.didMountContentDomElement) {\n      return null\n    }\n    return this.contentDOMElement as HTMLElement\n  }\n}\n\nexport function ReactMarkViewRenderer(\n  component: React.ComponentType<MarkViewProps>,\n  options: Partial<ReactMarkViewRendererOptions> = {},\n): MarkViewRenderer {\n  return props => new ReactMarkView(component, props, options)\n}\n","import type { Editor } from '@tiptap/core'\nimport type {\n  ComponentClass,\n  ForwardRefExoticComponent,\n  FunctionComponent,\n  PropsWithoutRef,\n  ReactNode,\n  RefAttributes,\n} from 'react'\nimport { version as reactVersion } from 'react'\nimport { flushSync } from 'react-dom'\n\nimport type { EditorWithContentComponent } from './Editor.js'\n\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */\nfunction isClassComponent(Component: any) {\n  return !!(typeof Component === 'function' && Component.prototype && Component.prototype.isReactComponent)\n}\n\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */\nfunction isForwardRefComponent(Component: any) {\n  return !!(\n    typeof Component === 'object' &&\n    Component.$$typeof &&\n    (Component.$$typeof.toString() === 'Symbol(react.forward_ref)' ||\n      Component.$$typeof.description === 'react.forward_ref')\n  )\n}\n\n/**\n * Check if a component is a memoized component.\n * @param Component\n * @returns {boolean}\n */\nfunction isMemoComponent(Component: any) {\n  return !!(\n    typeof Component === 'object' &&\n    Component.$$typeof &&\n    (Component.$$typeof.toString() === 'Symbol(react.memo)' || Component.$$typeof.description === 'react.memo')\n  )\n}\n\n/**\n * Check if a component can safely receive a ref prop.\n * This includes class components, forwardRef components, and memoized components\n * that wrap forwardRef or class components.\n * @param Component\n * @returns {boolean}\n */\nfunction canReceiveRef(Component: any) {\n  // Check if it's a class component\n  if (isClassComponent(Component)) {\n    return true\n  }\n\n  // Check if it's a forwardRef component\n  if (isForwardRefComponent(Component)) {\n    return true\n  }\n\n  // Check if it's a memoized component\n  if (isMemoComponent(Component)) {\n    // For memoized components, check the wrapped component\n    const wrappedComponent = Component.type\n    if (wrappedComponent) {\n      return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent)\n    }\n  }\n\n  return false\n}\n\n/**\n * Check if we're running React 19+ by detecting if function components support ref props\n * @returns {boolean}\n */\nfunction isReact19Plus(): boolean {\n  // React 19 is detected by checking React version if available\n  // In practice, we'll use a more conservative approach and assume React 18 behavior\n  // unless we can definitively detect React 19\n  try {\n    // @ts-ignore\n    if (reactVersion) {\n      const majorVersion = parseInt(reactVersion.split('.')[0], 10)\n      return majorVersion >= 19\n    }\n  } catch {\n    // Fallback to React 18 behavior if we can't determine version\n  }\n  return false\n}\n\nexport interface ReactRendererOptions {\n  /**\n   * The editor instance.\n   * @type {Editor}\n   */\n  editor: Editor\n\n  /**\n   * The props for the component.\n   * @type {Record<string, any>}\n   * @default {}\n   */\n  props?: Record<string, any>\n\n  /**\n   * The tag name of the element.\n   * @type {string}\n   * @default 'div'\n   */\n  as?: string\n\n  /**\n   * The class name of the element.\n   * @type {string}\n   * @default ''\n   * @example 'foo bar'\n   */\n  className?: string\n}\n\ntype ComponentType<R, P> =\n  | ComponentClass<P>\n  | FunctionComponent<P>\n  | ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<R>>\n\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n */\nexport class ReactRenderer<R = unknown, P extends Record<string, any> = object> {\n  id: string\n\n  editor: Editor\n\n  component: any\n\n  element: Element\n\n  props: P\n\n  reactElement: ReactNode\n\n  ref: R | null = null\n\n  /**\n   * Immediately creates element and renders the provided React component.\n   */\n  constructor(\n    component: ComponentType<R, P>,\n    { editor, props = {}, as = 'div', className = '' }: ReactRendererOptions,\n  ) {\n    this.id = Math.floor(Math.random() * 0xffffffff).toString()\n    this.component = component\n    this.editor = editor as EditorWithContentComponent\n    this.props = props as P\n    this.element = document.createElement(as)\n    this.element.classList.add('react-renderer')\n\n    if (className) {\n      this.element.classList.add(...className.split(' '))\n    }\n\n    // If the editor is already initialized, we will need to\n    // synchronously render the component to ensure it renders\n    // together with Prosemirror's rendering.\n    if (this.editor.isInitialized) {\n      flushSync(() => {\n        this.render()\n      })\n    } else {\n      queueMicrotask(() => {\n        this.render()\n      })\n    }\n  }\n\n  /**\n   * Render the React component.\n   */\n  render(): void {\n    const Component = this.component\n    const props = this.props\n    const editor = this.editor as EditorWithContentComponent\n\n    // Handle ref forwarding with React 18/19 compatibility\n    const isReact19 = isReact19Plus()\n    const componentCanReceiveRef = canReceiveRef(Component)\n\n    const elementProps = { ...props }\n\n    // Always remove ref if the component cannot receive it (unless React 19+)\n    if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n      delete elementProps.ref\n    }\n\n    // Only assign our own ref if allowed\n    if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n      // @ts-ignore - Setting ref prop for compatible components\n      elementProps.ref = (ref: R) => {\n        this.ref = ref\n      }\n    }\n\n    this.reactElement = <Component {...elementProps} />\n\n    editor?.contentComponent?.setRenderer(this.id, this)\n  }\n\n  /**\n   * Re-renders the React component with new props.\n   */\n  updateProps(props: Record<string, any> = {}): void {\n    this.props = {\n      ...this.props,\n      ...props,\n    }\n\n    this.render()\n  }\n\n  /**\n   * Destroy the React component.\n   */\n  destroy(): void {\n    const editor = this.editor as EditorWithContentComponent\n\n    editor?.contentComponent?.removeRenderer(this.id)\n  }\n\n  /**\n   * Update the attributes of the element that holds the React component.\n   */\n  updateAttributes(attributes: Record<string, string>): void {\n    Object.keys(attributes).forEach(key => {\n      this.element.setAttribute(key, attributes[key])\n    })\n  }\n}\n","import type {\n  DecorationWithType,\n  Editor,\n  NodeViewRenderer,\n  NodeViewRendererOptions,\n  NodeViewRendererProps,\n} from '@tiptap/core'\nimport { getRenderedAttributes, NodeView } from '@tiptap/core'\nimport type { Node, Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport type { Decoration, DecorationSource, NodeView as ProseMirrorNodeView } from '@tiptap/pm/view'\nimport type { ComponentType, NamedExoticComponent } from 'react'\nimport { createElement, createRef, memo } from 'react'\n\nimport type { EditorWithContentComponent } from './Editor.js'\nimport { ReactRenderer } from './ReactRenderer.js'\nimport type { ReactNodeViewProps } from './types.js'\nimport type { ReactNodeViewContextProps } from './useReactNodeView.js'\nimport { ReactNodeViewContext } from './useReactNodeView.js'\n\nexport interface ReactNodeViewRendererOptions extends NodeViewRendererOptions {\n  /**\n   * This function is called when the node view is updated.\n   * It allows you to compare the old node with the new node and decide if the component should update.\n   */\n  update:\n    | ((props: {\n        oldNode: ProseMirrorNode\n        oldDecorations: readonly Decoration[]\n        oldInnerDecorations: DecorationSource\n        newNode: ProseMirrorNode\n        newDecorations: readonly Decoration[]\n        innerDecorations: DecorationSource\n        updateProps: () => void\n      }) => boolean)\n    | null\n  /**\n   * The tag name of the element wrapping the React component.\n   */\n  as?: string\n  /**\n   * The class name of the element wrapping the React component.\n   */\n  className?: string\n  /**\n   * Attributes that should be applied to the element wrapping the React component.\n   * If this is a function, it will be called each time the node view is updated.\n   * If this is an object, it will be applied once when the node view is mounted.\n   */\n  attrs?:\n    | Record<string, string>\n    | ((props: { node: ProseMirrorNode; HTMLAttributes: Record<string, any> }) => Record<string, string>)\n}\n\nexport class ReactNodeView<\n  T = HTMLElement,\n  Component extends ComponentType<ReactNodeViewProps<T>> = ComponentType<ReactNodeViewProps<T>>,\n  NodeEditor extends Editor = Editor,\n  Options extends ReactNodeViewRendererOptions = ReactNodeViewRendererOptions,\n> extends NodeView<Component, NodeEditor, Options> {\n  /**\n   * The renderer instance.\n   */\n  renderer!: ReactRenderer<unknown, ReactNodeViewProps<T>>\n\n  /**\n   * The element that holds the rich-text content of the node.\n   */\n  contentDOMElement!: HTMLElement | null\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    super(component, props, options)\n\n    if (!this.node.isLeaf) {\n      if (this.options.contentDOMElementTag) {\n        this.contentDOMElement = document.createElement(this.options.contentDOMElementTag)\n      } else {\n        this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div')\n      }\n\n      this.contentDOMElement.dataset.nodeViewContentReact = ''\n      this.contentDOMElement.dataset.nodeViewWrapper = ''\n\n      // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n      // With this fix it seems to work fine\n      // See: https://github.com/ueberdosis/tiptap/issues/1197\n      this.contentDOMElement.style.whiteSpace = 'inherit'\n\n      const contentTarget = this.dom.querySelector('[data-node-view-content]')\n\n      if (!contentTarget) {\n        return\n      }\n\n      contentTarget.appendChild(this.contentDOMElement)\n    }\n  }\n\n  /**\n   * Setup the React component.\n   * Called on initialization.\n   */\n  mount() {\n    const props = {\n      editor: this.editor,\n      node: this.node,\n      decorations: this.decorations as DecorationWithType[],\n      innerDecorations: this.innerDecorations,\n      view: this.view,\n      selected: false,\n      extension: this.extension,\n      HTMLAttributes: this.HTMLAttributes,\n      getPos: () => this.getPos(),\n      updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n      deleteNode: () => this.deleteNode(),\n      ref: createRef<T>(),\n    } satisfies ReactNodeViewProps<T>\n\n    if (!(this.component as any).displayName) {\n      const capitalizeFirstChar = (string: string): string => {\n        return string.charAt(0).toUpperCase() + string.substring(1)\n      }\n\n      this.component.displayName = capitalizeFirstChar(this.extension.name)\n    }\n\n    const onDragStart = this.onDragStart.bind(this)\n    const nodeViewContentRef: ReactNodeViewContextProps['nodeViewContentRef'] = element => {\n      if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n        // remove the nodeViewWrapper attribute from the element\n        if (element.hasAttribute('data-node-view-wrapper')) {\n          element.removeAttribute('data-node-view-wrapper')\n        }\n        element.appendChild(this.contentDOMElement)\n      }\n    }\n    const context = { onDragStart, nodeViewContentRef }\n    const Component = this.component\n    // For performance reasons, we memoize the provider component\n    // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n    const ReactNodeViewProvider: NamedExoticComponent<ReactNodeViewProps<T>> = memo(componentProps => {\n      return (\n        <ReactNodeViewContext.Provider value={context}>\n          {createElement(Component, componentProps)}\n        </ReactNodeViewContext.Provider>\n      )\n    })\n\n    ReactNodeViewProvider.displayName = 'ReactNodeView'\n\n    let as = this.node.isInline ? 'span' : 'div'\n\n    if (this.options.as) {\n      as = this.options.as\n    }\n\n    const { className = '' } = this.options\n\n    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this)\n\n    this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n      editor: this.editor,\n      props,\n      as,\n      className: `node-${this.node.type.name} ${className}`.trim(),\n    })\n\n    this.editor.on('selectionUpdate', this.handleSelectionUpdate)\n    this.updateElementAttributes()\n  }\n\n  /**\n   * Return the DOM element.\n   * This is the element that will be used to display the node view.\n   */\n  get dom() {\n    if (\n      this.renderer.element.firstElementChild &&\n      !this.renderer.element.firstElementChild?.hasAttribute('data-node-view-wrapper')\n    ) {\n      throw Error('Please use the NodeViewWrapper component for your node view.')\n    }\n\n    return this.renderer.element as HTMLElement\n  }\n\n  /**\n   * Return the content DOM element.\n   * This is the element that will be used to display the rich-text content of the node.\n   */\n  get contentDOM() {\n    if (this.node.isLeaf) {\n      return null\n    }\n\n    return this.contentDOMElement\n  }\n\n  /**\n   * On editor selection update, check if the node is selected.\n   * If it is, call `selectNode`, otherwise call `deselectNode`.\n   */\n  handleSelectionUpdate() {\n    const { from, to } = this.editor.state.selection\n    const pos = this.getPos()\n\n    if (typeof pos !== 'number') {\n      return\n    }\n\n    if (from <= pos && to >= pos + this.node.nodeSize) {\n      if (this.renderer.props.selected) {\n        return\n      }\n\n      this.selectNode()\n    } else {\n      if (!this.renderer.props.selected) {\n        return\n      }\n\n      this.deselectNode()\n    }\n  }\n\n  /**\n   * On update, update the React component.\n   * To prevent unnecessary updates, the `update` option can be used.\n   */\n  update(node: Node, decorations: readonly Decoration[], innerDecorations: DecorationSource): boolean {\n    const rerenderComponent = (props?: Record<string, any>) => {\n      this.renderer.updateProps(props)\n      if (typeof this.options.attrs === 'function') {\n        this.updateElementAttributes()\n      }\n    }\n\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    if (typeof this.options.update === 'function') {\n      const oldNode = this.node\n      const oldDecorations = this.decorations\n      const oldInnerDecorations = this.innerDecorations\n\n      this.node = node\n      this.decorations = decorations\n      this.innerDecorations = innerDecorations\n\n      return this.options.update({\n        oldNode,\n        oldDecorations,\n        newNode: node,\n        newDecorations: decorations,\n        oldInnerDecorations,\n        innerDecorations,\n        updateProps: () => rerenderComponent({ node, decorations, innerDecorations }),\n      })\n    }\n\n    if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n      return true\n    }\n\n    this.node = node\n    this.decorations = decorations\n    this.innerDecorations = innerDecorations\n\n    rerenderComponent({ node, decorations, innerDecorations })\n\n    return true\n  }\n\n  /**\n   * Select the node.\n   * Add the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  selectNode() {\n    this.renderer.updateProps({\n      selected: true,\n    })\n    this.renderer.element.classList.add('ProseMirror-selectednode')\n  }\n\n  /**\n   * Deselect the node.\n   * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n   */\n  deselectNode() {\n    this.renderer.updateProps({\n      selected: false,\n    })\n    this.renderer.element.classList.remove('ProseMirror-selectednode')\n  }\n\n  /**\n   * Destroy the React component instance.\n   */\n  destroy() {\n    this.renderer.destroy()\n    this.editor.off('selectionUpdate', this.handleSelectionUpdate)\n    this.contentDOMElement = null\n  }\n\n  /**\n   * Update the attributes of the top-level element that holds the React component.\n   * Applying the attributes defined in the `attrs` option.\n   */\n  updateElementAttributes() {\n    if (this.options.attrs) {\n      let attrsObj: Record<string, string> = {}\n\n      if (typeof this.options.attrs === 'function') {\n        const extensionAttributes = this.editor.extensionManager.attributes\n        const HTMLAttributes = getRenderedAttributes(this.node, extensionAttributes)\n\n        attrsObj = this.options.attrs({ node: this.node, HTMLAttributes })\n      } else {\n        attrsObj = this.options.attrs\n      }\n\n      this.renderer.updateAttributes(attrsObj)\n    }\n  }\n}\n\n/**\n * Create a React node view renderer.\n */\nexport function ReactNodeViewRenderer<T = HTMLElement>(\n  component: ComponentType<ReactNodeViewProps<T>>,\n  options?: Partial<ReactNodeViewRendererOptions>,\n): NodeViewRenderer {\n  return props => {\n    // try to get the parent component\n    // this is important for vue devtools to show the component hierarchy correctly\n    // maybe its `undefined` because <editor-content> isnt rendered yet\n    if (!(props.editor as EditorWithContentComponent).contentComponent) {\n      return {} as unknown as ProseMirrorNodeView\n    }\n\n    return new ReactNodeView<T>(component, props, options)\n  }\n}\n","export * from './Context.js'\nexport * from './EditorContent.js'\nexport * from './NodeViewContent.js'\nexport * from './NodeViewWrapper.js'\nexport * from './ReactMarkViewRenderer.js'\nexport * from './ReactNodeViewRenderer.js'\nexport * from './ReactRenderer.js'\nexport * from './types.js'\nexport * from './useEditor.js'\nexport * from './useEditorState.js'\nexport * from './useReactNodeView.js'\nexport * from '@tiptap/core'\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}