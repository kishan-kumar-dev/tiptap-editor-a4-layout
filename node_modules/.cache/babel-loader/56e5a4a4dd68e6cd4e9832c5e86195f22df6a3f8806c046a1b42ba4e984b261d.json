{"ast":null,"code":"// src/horizontal-rule.ts\nimport { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from \"@tiptap/core\";\nimport { NodeSelection, TextSelection } from \"@tiptap/pm/state\";\nvar HorizontalRule = Node.create({\n  name: \"horizontalRule\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block\",\n  parseHTML() {\n    return [{\n      tag: \"hr\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"hr\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({\n        chain,\n        state\n      }) => {\n        if (!canInsertNode(state, state.schema.nodes[this.name])) {\n          return false;\n        }\n        const {\n          selection\n        } = state;\n        const {\n          $to: $originTo\n        } = selection;\n        const currentChain = chain();\n        if (isNodeSelection(selection)) {\n          currentChain.insertContentAt($originTo.pos, {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({\n            type: this.name\n          });\n        }\n        return currentChain.command(({\n          tr,\n          dispatch\n        }) => {\n          var _a;\n          if (dispatch) {\n            const {\n              $to\n            } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              const node = (_a = $to.parent.type.contentMatch.defaultType) == null ? void 0 : _a.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n});\n\n// src/index.ts\nvar index_default = HorizontalRule;\nexport { HorizontalRule, index_default as default };","map":{"version":3,"names":["canInsertNode","isNodeSelection","mergeAttributes","Node","nodeInputRule","NodeSelection","TextSelection","HorizontalRule","create","name","addOptions","HTMLAttributes","group","parseHTML","tag","renderHTML","options","addCommands","setHorizontalRule","chain","state","schema","nodes","selection","$to","$originTo","currentChain","insertContentAt","pos","type","insertContent","command","tr","dispatch","_a","posAfter","end","nodeAfter","isTextblock","setSelection","doc","isBlock","node","parent","contentMatch","defaultType","insert","scrollIntoView","run","addInputRules","find","index_default"],"sources":["C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-horizontal-rule\\src\\horizontal-rule.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-horizontal-rule\\src\\index.ts"],"sourcesContent":["import { canInsertNode, isNodeSelection, mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  /**\n   * The HTML attributes for a horizontal rule node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       * @example editor.commands.setHorizontalRule()\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () =>\n        ({ chain, state }) => {\n          // Check if we can insert the node at the current selection\n          if (!canInsertNode(state, state.schema.nodes[this.name])) {\n            return false\n          }\n\n          const { selection } = state\n          const { $to: $originTo } = selection\n\n          const currentChain = chain()\n\n          if (isNodeSelection(selection)) {\n            currentChain.insertContentAt($originTo.pos, {\n              type: this.name,\n            })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if it’s the end of the document\n                    const node = $to.parent.type.contentMatch.defaultType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n","import { HorizontalRule } from './horizontal-rule.js'\n\nexport * from './horizontal-rule.js'\n\nexport default HorizontalRule\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}