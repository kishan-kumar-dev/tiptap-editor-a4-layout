{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/bullet-list/bullet-list.ts\nimport { mergeAttributes, Node, wrappingInputRule } from \"@tiptap/core\";\nvar ListItemName = \"listItem\";\nvar TextStyleName = \"textStyle\";\nvar bulletListInputRegex = /^\\s*([-+*])\\s$/;\nvar BulletList = Node.create({\n  name: \"bulletList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{\n      tag: \"ul\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"ul\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      toggleBulletList: () => ({\n        commands,\n        chain\n      }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-8\": () => this.editor.commands.toggleBulletList()\n    };\n  },\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName);\n        },\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/item/list-item.ts\nimport { mergeAttributes as mergeAttributes2, Node as Node2 } from \"@tiptap/core\";\nvar ListItem = Node2.create({\n  name: \"listItem\",\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: \"bulletList\",\n      orderedListTypeName: \"orderedList\"\n    };\n  },\n  content: \"paragraph block*\",\n  defining: true,\n  parseHTML() {\n    return [{\n      tag: \"li\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"li\", mergeAttributes2(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n  }\n});\n\n// src/keymap/list-keymap.ts\nimport { Extension } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/index.ts\nvar listHelpers_exports = {};\n__export(listHelpers_exports, {\n  findListItemPos: () => findListItemPos,\n  getNextListDepth: () => getNextListDepth,\n  handleBackspace: () => handleBackspace,\n  handleDelete: () => handleDelete,\n  hasListBefore: () => hasListBefore,\n  hasListItemAfter: () => hasListItemAfter,\n  hasListItemBefore: () => hasListItemBefore,\n  listItemHasSubList: () => listItemHasSubList,\n  nextListIsDeeper: () => nextListIsDeeper,\n  nextListIsHigher: () => nextListIsHigher\n});\n\n// src/keymap/listHelpers/findListItemPos.ts\nimport { getNodeType } from \"@tiptap/core\";\nvar findListItemPos = (typeOrName, state) => {\n  const {\n    $from\n  } = state.selection;\n  const nodeType = getNodeType(typeOrName, state.schema);\n  let currentNode = null;\n  let currentDepth = $from.depth;\n  let currentPos = $from.pos;\n  let targetDepth = null;\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth);\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth;\n    } else {\n      currentDepth -= 1;\n      currentPos -= 1;\n    }\n  }\n  if (targetDepth === null) {\n    return null;\n  }\n  return {\n    $pos: state.doc.resolve(currentPos),\n    depth: targetDepth\n  };\n};\n\n// src/keymap/listHelpers/getNextListDepth.ts\nimport { getNodeAtPosition } from \"@tiptap/core\";\nvar getNextListDepth = (typeOrName, state) => {\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos) {\n    return false;\n  }\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4);\n  return depth;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nimport { isAtStartOfNode, isNodeActive } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/hasListBefore.ts\nvar hasListBefore = (editorState, name, parentListTypes) => {\n  const {\n    $anchor\n  } = editorState.selection;\n  const previousNodePos = Math.max(0, $anchor.pos - 2);\n  const previousNode = editorState.doc.resolve(previousNodePos).node();\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/hasListItemBefore.ts\nvar hasListItemBefore = (typeOrName, state) => {\n  var _a;\n  const {\n    $anchor\n  } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - 2);\n  if ($targetPos.index() === 0) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/listHelpers/listItemHasSubList.ts\nimport { getNodeType as getNodeType2 } from \"@tiptap/core\";\nvar listItemHasSubList = (typeOrName, state, node) => {\n  if (!node) {\n    return false;\n  }\n  const nodeType = getNodeType2(typeOrName, state.schema);\n  let hasSubList = false;\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true;\n    }\n  });\n  return hasSubList;\n};\n\n// src/keymap/listHelpers/handleBackspace.ts\nvar handleBackspace = (editor, name, parentListTypes) => {\n  if (editor.commands.undoInputRule()) {\n    return true;\n  }\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false;\n  }\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const {\n      $anchor\n    } = editor.state.selection;\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1);\n    const listDescendants = [];\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({\n          node,\n          pos\n        });\n      }\n    });\n    const lastItem = listDescendants.at(-1);\n    if (!lastItem) {\n      return false;\n    }\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);\n    return editor.chain().cut({\n      from: $anchor.start() - 1,\n      to: $anchor.end() + 1\n    }, $lastItemPos.end()).joinForward().run();\n  }\n  if (!isNodeActive(editor.state, name)) {\n    return false;\n  }\n  if (!isAtStartOfNode(editor.state)) {\n    return false;\n  }\n  const listItemPos = findListItemPos(name, editor.state);\n  if (!listItemPos) {\n    return false;\n  }\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);\n  const prevNode = $prev.node(listItemPos.depth);\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward();\n  }\n  return editor.chain().liftListItem(name).run();\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nimport { isAtEndOfNode, isNodeActive as isNodeActive2 } from \"@tiptap/core\";\n\n// src/keymap/listHelpers/nextListIsDeeper.ts\nvar nextListIsDeeper = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth > listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/nextListIsHigher.ts\nvar nextListIsHigher = (typeOrName, state) => {\n  const listDepth = getNextListDepth(typeOrName, state);\n  const listItemPos = findListItemPos(typeOrName, state);\n  if (!listItemPos || !listDepth) {\n    return false;\n  }\n  if (listDepth < listItemPos.depth) {\n    return true;\n  }\n  return false;\n};\n\n// src/keymap/listHelpers/handleDelete.ts\nvar handleDelete = (editor, name) => {\n  if (!isNodeActive2(editor.state, name)) {\n    return false;\n  }\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false;\n  }\n  const {\n    selection\n  } = editor.state;\n  const {\n    $from,\n    $to\n  } = selection;\n  if (!selection.empty && $from.sameParent($to)) {\n    return false;\n  }\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();\n  }\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run();\n  }\n  return editor.commands.joinItemForward();\n};\n\n// src/keymap/listHelpers/hasListItemAfter.ts\nvar hasListItemAfter = (typeOrName, state) => {\n  var _a;\n  const {\n    $anchor\n  } = state.selection;\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false;\n  }\n  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {\n    return false;\n  }\n  return true;\n};\n\n// src/keymap/list-keymap.ts\nvar ListKeymap = Extension.create({\n  name: \"listKeymap\",\n  addOptions() {\n    return {\n      listTypes: [{\n        itemName: \"listItem\",\n        wrapperNames: [\"bulletList\", \"orderedList\"]\n      }, {\n        itemName: \"taskItem\",\n        wrapperNames: [\"taskList\"]\n      }]\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({\n        editor\n      }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({\n          itemName\n        }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Delete\": ({\n        editor\n      }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({\n          itemName\n        }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleDelete(editor, itemName)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      Backspace: ({\n        editor\n      }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({\n          itemName,\n          wrapperNames\n        }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      },\n      \"Mod-Backspace\": ({\n        editor\n      }) => {\n        let handled = false;\n        this.options.listTypes.forEach(({\n          itemName,\n          wrapperNames\n        }) => {\n          if (editor.state.schema.nodes[itemName] === void 0) {\n            return;\n          }\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true;\n          }\n        });\n        return handled;\n      }\n    };\n  }\n});\n\n// src/kit/index.ts\nimport { Extension as Extension2 } from \"@tiptap/core\";\n\n// src/ordered-list/ordered-list.ts\nimport { mergeAttributes as mergeAttributes3, Node as Node3, wrappingInputRule as wrappingInputRule2 } from \"@tiptap/core\";\nvar ListItemName2 = \"listItem\";\nvar TextStyleName2 = \"textStyle\";\nvar orderedListInputRegex = /^(\\d+)\\.\\s$/;\nvar OrderedList = Node3.create({\n  name: \"orderedList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n        }\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute(\"type\")\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: \"ol\"\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    const {\n      start,\n      ...attributesWithoutStart\n    } = HTMLAttributes;\n    return start === 1 ? [\"ol\", mergeAttributes3(this.options.HTMLAttributes, attributesWithoutStart), 0] : [\"ol\", mergeAttributes3(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({\n        commands,\n        chain\n      }) => {\n        if (this.options.keepAttributes) {\n          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();\n        }\n        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-7\": () => this.editor.commands.toggleOrderedList()\n    };\n  },\n  addInputRules() {\n    let inputRule = wrappingInputRule2({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({\n        start: +match[1]\n      }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]\n    });\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule2({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({\n          start: +match[1],\n          ...this.editor.getAttributes(TextStyleName2)\n        }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor\n      });\n    }\n    return [inputRule];\n  }\n});\n\n// src/task-item/task-item.ts\nimport { mergeAttributes as mergeAttributes4, Node as Node4, wrappingInputRule as wrappingInputRule3 } from \"@tiptap/core\";\nvar inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\nvar TaskItem = Node4.create({\n  name: \"taskItem\",\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: \"taskList\",\n      a11y: void 0\n    };\n  },\n  content() {\n    return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n  },\n  defining: true,\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute(\"data-checked\");\n          return dataChecked === \"\" || dataChecked === \"true\";\n        },\n        renderHTML: attributes => ({\n          \"data-checked\": attributes.checked\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: `li[data-type=\"${this.name}\"]`,\n      priority: 51\n    }];\n  },\n  renderHTML({\n    node,\n    HTMLAttributes\n  }) {\n    return [\"li\", mergeAttributes4(this.options.HTMLAttributes, HTMLAttributes, {\n      \"data-type\": this.name\n    }), [\"label\", [\"input\", {\n      type: \"checkbox\",\n      checked: node.attrs.checked ? \"checked\" : null\n    }], [\"span\"]], [\"div\", 0]];\n  },\n  addKeyboardShortcuts() {\n    const shortcuts = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n    if (!this.options.nested) {\n      return shortcuts;\n    }\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name)\n    };\n  },\n  addNodeView() {\n    return ({\n      node,\n      HTMLAttributes,\n      getPos,\n      editor\n    }) => {\n      const listItem = document.createElement(\"li\");\n      const checkboxWrapper = document.createElement(\"label\");\n      const checkboxStyler = document.createElement(\"span\");\n      const checkbox = document.createElement(\"input\");\n      const content = document.createElement(\"div\");\n      const updateA11Y = currentNode => {\n        var _a, _b;\n        checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || \"empty task item\"}`;\n      };\n      updateA11Y(node);\n      checkboxWrapper.contentEditable = \"false\";\n      checkbox.type = \"checkbox\";\n      checkbox.addEventListener(\"mousedown\", event => event.preventDefault());\n      checkbox.addEventListener(\"change\", event => {\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked;\n          return;\n        }\n        const {\n          checked\n        } = event.target;\n        if (editor.isEditable && typeof getPos === \"function\") {\n          editor.chain().focus(void 0, {\n            scrollIntoView: false\n          }).command(({\n            tr\n          }) => {\n            const position = getPos();\n            if (typeof position !== \"number\") {\n              return false;\n            }\n            const currentNode = tr.doc.nodeAt(position);\n            tr.setNodeMarkup(position, void 0, {\n              ...(currentNode == null ? void 0 : currentNode.attrs),\n              checked\n            });\n            return true;\n          }).run();\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked;\n          }\n        }\n      });\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      listItem.dataset.checked = node.attrs.checked;\n      checkbox.checked = node.attrs.checked;\n      checkboxWrapper.append(checkbox, checkboxStyler);\n      listItem.append(checkboxWrapper, content);\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value);\n      });\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false;\n          }\n          listItem.dataset.checked = updatedNode.attrs.checked;\n          checkbox.checked = updatedNode.attrs.checked;\n          updateA11Y(updatedNode);\n          return true;\n        }\n      };\n    };\n  },\n  addInputRules() {\n    return [wrappingInputRule3({\n      find: inputRegex,\n      type: this.type,\n      getAttributes: match => ({\n        checked: match[match.length - 1] === \"x\"\n      })\n    })];\n  }\n});\n\n// src/task-list/task-list.ts\nimport { mergeAttributes as mergeAttributes5, Node as Node5 } from \"@tiptap/core\";\nvar TaskList = Node5.create({\n  name: \"taskList\",\n  addOptions() {\n    return {\n      itemTypeName: \"taskItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [{\n      tag: `ul[data-type=\"${this.name}\"]`,\n      priority: 51\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return [\"ul\", mergeAttributes5(this.options.HTMLAttributes, HTMLAttributes, {\n      \"data-type\": this.name\n    }), 0];\n  },\n  addCommands() {\n    return {\n      toggleTaskList: () => ({\n        commands\n      }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-9\": () => this.editor.commands.toggleTaskList()\n    };\n  }\n});\n\n// src/kit/index.ts\nvar ListKit = Extension2.create({\n  name: \"listKit\",\n  addExtensions() {\n    const extensions = [];\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem));\n    }\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList));\n    }\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem));\n    }\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList));\n    }\n    return extensions;\n  }\n});\nexport { BulletList, ListItem, ListKeymap, ListKit, OrderedList, TaskItem, TaskList, bulletListInputRegex, inputRegex, listHelpers_exports as listHelpers, orderedListInputRegex };","map":{"version":3,"names":["mergeAttributes","Node","wrappingInputRule","ListItemName","TextStyleName","bulletListInputRegex","BulletList","create","name","addOptions","itemTypeName","HTMLAttributes","keepMarks","keepAttributes","group","content","options","parseHTML","tag","renderHTML","addCommands","toggleBulletList","commands","chain","toggleList","updateAttributes","editor","getAttributes","run","addKeyboardShortcuts","Mod-Shift-8","addInputRules","inputRule","find","type","mergeAttributes2","Node2","ListItem","bulletListTypeName","orderedListTypeName","defining","Enter","splitListItem","Tab","sinkListItem","Shift-Tab","liftListItem","Extension","listHelpers_exports","__export","findListItemPos","getNextListDepth","handleBackspace","handleDelete","hasListBefore","hasListItemAfter","hasListItemBefore","listItemHasSubList","nextListIsDeeper","nextListIsHigher","getNodeType","typeOrName","state","$from","selection","nodeType","schema","currentNode","currentDepth","depth","currentPos","pos","targetDepth","node","$pos","doc","resolve","getNodeAtPosition","listItemPos","isAtStartOfNode","isNodeActive","editorState","parentListTypes","$anchor","previousNodePos","Math","max","previousNode","includes","_a","$targetPos","index","nodeBefore","getNodeType2","hasSubList","descendants","child","undoInputRule","from","to","$listPos","before","listDescendants","push","lastItem","at","$lastItemPos","start","cut","end","joinForward","$prev","prevNode","previousListItemHasSubList","joinItemBackward","isAtEndOfNode","isNodeActive2","listDepth","$to","empty","sameParent","focus","lift","joinBackward","joinItemForward","parentOffset","parent","childCount","nodeAfter","ListKeymap","listTypes","itemName","wrapperNames","Delete","handled","forEach","nodes","Mod-Delete","Backspace","Mod-Backspace","Extension2","mergeAttributes3","Node3","wrappingInputRule2","ListItemName2","TextStyleName2","orderedListInputRegex","OrderedList","addAttributes","default","element","hasAttribute","parseInt","getAttribute","attributesWithoutStart","toggleOrderedList","Mod-Shift-7","match","joinPredicate","attrs","mergeAttributes4","Node4","wrappingInputRule3","inputRegex","TaskItem","nested","taskListTypeName","a11y","checked","keepOnSplit","dataChecked","attributes","priority","shortcuts","addNodeView","getPos","listItem","document","createElement","checkboxWrapper","checkboxStyler","checkbox","updateA11Y","_b","ariaLabel","checkboxLabel","call","textContent","contentEditable","addEventListener","event","preventDefault","isEditable","onReadOnlyChecked","target","scrollIntoView","command","tr","position","nodeAt","setNodeMarkup","Object","entries","key","value","setAttribute","dataset","append","dom","contentDOM","update","updatedNode","length","mergeAttributes5","Node5","TaskList","toggleTaskList","Mod-Shift-9","ListKit","addExtensions","extensions","bulletList","configure","listKeymap","orderedList","taskItem","taskList"],"sources":["C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\bullet-list\\bullet-list.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\item\\list-item.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\list-keymap.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\index.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\findListItemPos.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\getNextListDepth.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\handleBackspace.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\hasListBefore.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\hasListItemBefore.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\listItemHasSubList.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\handleDelete.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\nextListIsDeeper.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\nextListIsHigher.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\keymap\\listHelpers\\hasListItemAfter.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\kit\\index.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\ordered-list\\ordered-list.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\task-item\\task-item.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extension-list\\src\\task-list\\task-list.ts"],"sourcesContent":["import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface BulletListOptions {\n  /**\n   * The node name for the list items\n   * @default 'listItem'\n   * @example 'paragraph'\n   */\n  itemTypeName: string\n\n  /**\n   * HTML attributes to add to the bullet list element\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting the list\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting the list\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    bulletList: {\n      /**\n       * Toggle a bullet list\n       */\n      toggleBulletList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nexport const bulletListInputRegex = /^\\s*([-+*])\\s$/\n\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nexport const BulletList = Node.create<BulletListOptions>({\n  name: 'bulletList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [{ tag: 'ul' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleBulletList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: bulletListInputRegex,\n      type: this.type,\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: bulletListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: () => {\n          return this.editor.getAttributes(TextStyleName)\n        },\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface ListItemOptions {\n  /**\n   * The HTML attributes for a list item node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for bulletList nodes\n   * @default 'bulletList'\n   * @example 'myCustomBulletList'\n   */\n  bulletListTypeName: string\n\n  /**\n   * The node type for orderedList nodes\n   * @default 'orderedList'\n   * @example 'myCustomOrderedList'\n   */\n  orderedListTypeName: string\n}\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const ListItem = Node.create<ListItemOptions>({\n  name: 'listItem',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      bulletListTypeName: 'bulletList',\n      orderedListTypeName: 'orderedList',\n    }\n  },\n\n  content: 'paragraph block*',\n\n  defining: true,\n\n  parseHTML() {\n    return [\n      {\n        tag: 'li',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n  },\n})\n","import { Extension } from '@tiptap/core'\n\nimport { handleBackspace, handleDelete } from './listHelpers/index.js'\n\nexport type ListKeymapOptions = {\n  /**\n   * An array of list types. This is used for item and wrapper list matching.\n   * @default []\n   * @example [{ itemName: 'listItem', wrapperNames: ['bulletList', 'orderedList'] }]\n   */\n  listTypes: Array<{\n    itemName: string\n    wrapperNames: string[]\n  }>\n}\n\n/**\n * This extension registers custom keymaps to change the behaviour of the backspace and delete keys.\n * By default Prosemirror keyhandling will always lift or sink items so paragraphs are joined into\n * the adjacent or previous list item. This extension will prevent this behaviour and instead will\n * try to join paragraphs from two list items into a single list item.\n * @see https://www.tiptap.dev/api/extensions/list-keymap\n */\nexport const ListKeymap = Extension.create<ListKeymapOptions>({\n  name: 'listKeymap',\n\n  addOptions() {\n    return {\n      listTypes: [\n        {\n          itemName: 'listItem',\n          wrapperNames: ['bulletList', 'orderedList'],\n        },\n        {\n          itemName: 'taskItem',\n          wrapperNames: ['taskList'],\n        },\n      ],\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Delete: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Delete': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleDelete(editor, itemName)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      Backspace: ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n      'Mod-Backspace': ({ editor }) => {\n        let handled = false\n\n        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {\n          if (editor.state.schema.nodes[itemName] === undefined) {\n            return\n          }\n\n          if (handleBackspace(editor, itemName, wrapperNames)) {\n            handled = true\n          }\n        })\n\n        return handled\n      },\n    }\n  },\n})\n","export * from './findListItemPos.js'\nexport * from './getNextListDepth.js'\nexport * from './handleBackspace.js'\nexport * from './handleDelete.js'\nexport * from './hasListBefore.js'\nexport * from './hasListItemAfter.js'\nexport * from './hasListItemBefore.js'\nexport * from './listItemHasSubList.js'\nexport * from './nextListIsDeeper.js'\nexport * from './nextListIsHigher.js'\n","import { getNodeType } from '@tiptap/core'\nimport type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const findListItemPos = (typeOrName: string | NodeType, state: EditorState) => {\n  const { $from } = state.selection\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let currentNode = null\n  let currentDepth = $from.depth\n  let currentPos = $from.pos\n  let targetDepth: number | null = null\n\n  while (currentDepth > 0 && targetDepth === null) {\n    currentNode = $from.node(currentDepth)\n\n    if (currentNode.type === nodeType) {\n      targetDepth = currentDepth\n    } else {\n      currentDepth -= 1\n      currentPos -= 1\n    }\n  }\n\n  if (targetDepth === null) {\n    return null\n  }\n\n  return { $pos: state.doc.resolve(currentPos), depth: targetDepth }\n}\n","import { getNodeAtPosition } from '@tiptap/core'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\n\nexport const getNextListDepth = (typeOrName: string, state: EditorState) => {\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4)\n\n  return depth\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtStartOfNode, isNodeActive } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { hasListBefore } from './hasListBefore.js'\nimport { hasListItemBefore } from './hasListItemBefore.js'\nimport { listItemHasSubList } from './listItemHasSubList.js'\n\nexport const handleBackspace = (editor: Editor, name: string, parentListTypes: string[]) => {\n  // this is required to still handle the undo handling\n  if (editor.commands.undoInputRule()) {\n    return true\n  }\n\n  // if the selection is not collapsed\n  // we can rely on the default backspace behavior\n  if (editor.state.selection.from !== editor.state.selection.to) {\n    return false\n  }\n\n  // if the current item is NOT inside a list item &\n  // the previous item is a list (orderedList or bulletList)\n  // move the cursor into the list and delete the current item\n  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {\n    const { $anchor } = editor.state.selection\n\n    const $listPos = editor.state.doc.resolve($anchor.before() - 1)\n\n    const listDescendants: Array<{ node: Node; pos: number }> = []\n\n    $listPos.node().descendants((node, pos) => {\n      if (node.type.name === name) {\n        listDescendants.push({ node, pos })\n      }\n    })\n\n    const lastItem = listDescendants.at(-1)\n\n    if (!lastItem) {\n      return false\n    }\n\n    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1)\n\n    return editor\n      .chain()\n      .cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end())\n      .joinForward()\n      .run()\n  }\n\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the start of a node\n  // do nothing and proceed\n  if (!isAtStartOfNode(editor.state)) {\n    return false\n  }\n\n  const listItemPos = findListItemPos(name, editor.state)\n\n  if (!listItemPos) {\n    return false\n  }\n\n  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2)\n  const prevNode = $prev.node(listItemPos.depth)\n\n  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode)\n\n  // if the previous item is a list item and doesn't have a sublist, join the list items\n  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {\n    return editor.commands.joinItemBackward()\n  }\n\n  // otherwise in the end, a backspace should\n  // always just lift the list item if\n  // joining / merging is not possible\n  return editor.chain().liftListItem(name).run()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListBefore = (editorState: EditorState, name: string, parentListTypes: string[]) => {\n  const { $anchor } = editorState.selection\n\n  const previousNodePos = Math.max(0, $anchor.pos - 2)\n\n  const previousNode = editorState.doc.resolve(previousNodePos).node()\n\n  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {\n    return false\n  }\n\n  return true\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemBefore = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - 2)\n\n  if ($targetPos.index() === 0) {\n    return false\n  }\n\n  if ($targetPos.nodeBefore?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { getNodeType } from '@tiptap/core'\nimport type { Node } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nexport const listItemHasSubList = (typeOrName: string, state: EditorState, node?: Node) => {\n  if (!node) {\n    return false\n  }\n\n  const nodeType = getNodeType(typeOrName, state.schema)\n\n  let hasSubList = false\n\n  node.descendants(child => {\n    if (child.type === nodeType) {\n      hasSubList = true\n    }\n  })\n\n  return hasSubList\n}\n","import type { Editor } from '@tiptap/core'\nimport { isAtEndOfNode, isNodeActive } from '@tiptap/core'\n\nimport { nextListIsDeeper } from './nextListIsDeeper.js'\nimport { nextListIsHigher } from './nextListIsHigher.js'\n\nexport const handleDelete = (editor: Editor, name: string) => {\n  // if the cursor is not inside the current node type\n  // do nothing and proceed\n  if (!isNodeActive(editor.state, name)) {\n    return false\n  }\n\n  // if the cursor is not at the end of a node\n  // do nothing and proceed\n  if (!isAtEndOfNode(editor.state, name)) {\n    return false\n  }\n\n  // if the selection is not collapsed, or not within a single node\n  // do nothing and proceed\n  const { selection } = editor.state\n  const { $from, $to } = selection\n\n  if (!selection.empty && $from.sameParent($to)) {\n    return false\n  }\n\n  // check if the next node is a list with a deeper depth\n  if (nextListIsDeeper(name, editor.state)) {\n    return editor\n      .chain()\n      .focus(editor.state.selection.from + 4)\n      .lift(name)\n      .joinBackward()\n      .run()\n  }\n\n  if (nextListIsHigher(name, editor.state)) {\n    return editor.chain().joinForward().joinBackward().run()\n  }\n\n  return editor.commands.joinItemForward()\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsDeeper = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth > listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findListItemPos } from './findListItemPos.js'\nimport { getNextListDepth } from './getNextListDepth.js'\n\nexport const nextListIsHigher = (typeOrName: string, state: EditorState) => {\n  const listDepth = getNextListDepth(typeOrName, state)\n  const listItemPos = findListItemPos(typeOrName, state)\n\n  if (!listItemPos || !listDepth) {\n    return false\n  }\n\n  if (listDepth < listItemPos.depth) {\n    return true\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const hasListItemAfter = (typeOrName: string, state: EditorState): boolean => {\n  const { $anchor } = state.selection\n\n  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2)\n\n  if ($targetPos.index() === $targetPos.parent.childCount - 1) {\n    return false\n  }\n\n  if ($targetPos.nodeAfter?.type.name !== typeOrName) {\n    return false\n  }\n\n  return true\n}\n","import { Extension } from '@tiptap/core'\n\nimport type { BulletListOptions } from '../bullet-list/index.js'\nimport { BulletList } from '../bullet-list/index.js'\nimport type { ListItemOptions } from '../item/index.js'\nimport { ListItem } from '../item/index.js'\nimport type { ListKeymapOptions } from '../keymap/index.js'\nimport { ListKeymap } from '../keymap/index.js'\nimport type { OrderedListOptions } from '../ordered-list/index.js'\nimport { OrderedList } from '../ordered-list/index.js'\nimport type { TaskItemOptions } from '../task-item/index.js'\nimport { TaskItem } from '../task-item/index.js'\nimport type { TaskListOptions } from '../task-list/index.js'\nimport { TaskList } from '../task-list/index.js'\n\nexport interface ListKitOptions {\n  /**\n   * If set to false, the bulletList extension will not be registered\n   * @example table: false\n   */\n  bulletList: Partial<BulletListOptions> | false\n  /**\n   * If set to false, the listItem extension will not be registered\n   */\n  listItem: Partial<ListItemOptions> | false\n  /**\n   * If set to false, the listKeymap extension will not be registered\n   */\n  listKeymap: Partial<ListKeymapOptions> | false\n  /**\n   * If set to false, the orderedList extension will not be registered\n   */\n  orderedList: Partial<OrderedListOptions> | false\n  /**\n   * If set to false, the taskItem extension will not be registered\n   */\n  taskItem: Partial<TaskItemOptions> | false\n  /**\n   * If set to false, the taskList extension will not be registered\n   */\n  taskList: Partial<TaskListOptions> | false\n}\n\n/**\n * The table kit is a collection of table editor extensions.\n *\n * Itâ€™s a good starting point for building your own table in Tiptap.\n */\nexport const ListKit = Extension.create<ListKitOptions>({\n  name: 'listKit',\n\n  addExtensions() {\n    const extensions = []\n\n    if (this.options.bulletList !== false) {\n      extensions.push(BulletList.configure(this.options.bulletList))\n    }\n\n    if (this.options.listItem !== false) {\n      extensions.push(ListItem.configure(this.options.listItem))\n    }\n\n    if (this.options.listKeymap !== false) {\n      extensions.push(ListKeymap.configure(this.options.listKeymap))\n    }\n\n    if (this.options.orderedList !== false) {\n      extensions.push(OrderedList.configure(this.options.orderedList))\n    }\n\n    if (this.options.taskItem !== false) {\n      extensions.push(TaskItem.configure(this.options.taskItem))\n    }\n\n    if (this.options.taskList !== false) {\n      extensions.push(TaskList.configure(this.options.taskList))\n    }\n\n    return extensions\n  },\n})\n","import { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\n\nconst ListItemName = 'listItem'\nconst TextStyleName = 'textStyle'\n\nexport interface OrderedListOptions {\n  /**\n   * The node type name for list items.\n   * @default 'listItem'\n   * @example 'myListItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for an ordered list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Keep the marks when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepMarks: boolean\n\n  /**\n   * Keep the attributes when splitting a list item.\n   * @default false\n   * @example true\n   */\n  keepAttributes: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    orderedList: {\n      /**\n       * Toggle an ordered list\n       * @example editor.commands.toggleOrderedList()\n       */\n      toggleOrderedList: () => ReturnType\n    }\n  }\n}\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nexport const orderedListInputRegex = /^(\\d+)\\.\\s$/\n\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nexport const OrderedList = Node.create<OrderedListOptions>({\n  name: 'orderedList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'listItem',\n      HTMLAttributes: {},\n      keepMarks: false,\n      keepAttributes: false,\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: element => {\n          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1\n        },\n      },\n      type: {\n        default: null,\n        parseHTML: element => element.getAttribute('type'),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'ol',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    const { start, ...attributesWithoutStart } = HTMLAttributes\n\n    return start === 1\n      ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n      : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleOrderedList:\n        () =>\n        ({ commands, chain }) => {\n          if (this.options.keepAttributes) {\n            return chain()\n              .toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n              .updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName))\n              .run()\n          }\n          return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n    }\n  },\n\n  addInputRules() {\n    let inputRule = wrappingInputRule({\n      find: orderedListInputRegex,\n      type: this.type,\n      getAttributes: match => ({ start: +match[1] }),\n      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n    })\n\n    if (this.options.keepMarks || this.options.keepAttributes) {\n      inputRule = wrappingInputRule({\n        find: orderedListInputRegex,\n        type: this.type,\n        keepMarks: this.options.keepMarks,\n        keepAttributes: this.options.keepAttributes,\n        getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        editor: this.editor,\n      })\n    }\n    return [inputRule]\n  },\n})\n","import type { KeyboardShortcutCommand } from '@tiptap/core'\nimport { mergeAttributes, Node, wrappingInputRule } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nexport interface TaskItemOptions {\n  /**\n   * A callback function that is called when the checkbox is clicked while the editor is in readonly mode.\n   * @param node The prosemirror node of the task item\n   * @param checked The new checked state\n   * @returns boolean\n   */\n  onReadOnlyChecked?: (node: ProseMirrorNode, checked: boolean) => boolean\n\n  /**\n   * Controls whether the task items can be nested or not.\n   * @default false\n   * @example true\n   */\n  nested: boolean\n\n  /**\n   * HTML attributes to add to the task item element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * The node type for taskList nodes\n   * @default 'taskList'\n   * @example 'myCustomTaskList'\n   */\n  taskListTypeName: string\n\n  /**\n   * Accessibility options for the task item.\n   * @default {}\n   * @example\n   * ```js\n   * {\n   *   checkboxLabel: (node) => `Task item: ${node.textContent || 'empty task item'}`\n   * }\n   */\n  a11y?: {\n    checkboxLabel?: (node: ProseMirrorNode, checked: boolean) => string\n  }\n}\n\n/**\n * Matches a task item to a - [ ] on input.\n */\nexport const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/\n\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */\nexport const TaskItem = Node.create<TaskItemOptions>({\n  name: 'taskItem',\n\n  addOptions() {\n    return {\n      nested: false,\n      HTMLAttributes: {},\n      taskListTypeName: 'taskList',\n      a11y: undefined,\n    }\n  },\n\n  content() {\n    return this.options.nested ? 'paragraph block*' : 'paragraph+'\n  },\n\n  defining: true,\n\n  addAttributes() {\n    return {\n      checked: {\n        default: false,\n        keepOnSplit: false,\n        parseHTML: element => {\n          const dataChecked = element.getAttribute('data-checked')\n\n          return dataChecked === '' || dataChecked === 'true'\n        },\n        renderHTML: attributes => ({\n          'data-checked': attributes.checked,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `li[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      'li',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        'data-type': this.name,\n      }),\n      [\n        'label',\n        [\n          'input',\n          {\n            type: 'checkbox',\n            checked: node.attrs.checked ? 'checked' : null,\n          },\n        ],\n        ['span'],\n      ],\n      ['div', 0],\n    ]\n  },\n\n  addKeyboardShortcuts() {\n    const shortcuts: {\n      [key: string]: KeyboardShortcutCommand\n    } = {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n    }\n\n    if (!this.options.nested) {\n      return shortcuts\n    }\n\n    return {\n      ...shortcuts,\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n    }\n  },\n\n  addNodeView() {\n    return ({ node, HTMLAttributes, getPos, editor }) => {\n      const listItem = document.createElement('li')\n      const checkboxWrapper = document.createElement('label')\n      const checkboxStyler = document.createElement('span')\n      const checkbox = document.createElement('input')\n      const content = document.createElement('div')\n\n      const updateA11Y = (currentNode: ProseMirrorNode) => {\n        checkbox.ariaLabel =\n          this.options.a11y?.checkboxLabel?.(currentNode, checkbox.checked) ||\n          `Task item checkbox for ${currentNode.textContent || 'empty task item'}`\n      }\n\n      updateA11Y(node)\n\n      checkboxWrapper.contentEditable = 'false'\n      checkbox.type = 'checkbox'\n      checkbox.addEventListener('mousedown', event => event.preventDefault())\n      checkbox.addEventListener('change', event => {\n        // if the editor isnâ€™t editable and we don't have a handler for\n        // readonly checks we have to undo the latest change\n        if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n          checkbox.checked = !checkbox.checked\n\n          return\n        }\n\n        const { checked } = event.target as any\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          editor\n            .chain()\n            .focus(undefined, { scrollIntoView: false })\n            .command(({ tr }) => {\n              const position = getPos()\n\n              if (typeof position !== 'number') {\n                return false\n              }\n              const currentNode = tr.doc.nodeAt(position)\n\n              tr.setNodeMarkup(position, undefined, {\n                ...currentNode?.attrs,\n                checked,\n              })\n\n              return true\n            })\n            .run()\n        }\n        if (!editor.isEditable && this.options.onReadOnlyChecked) {\n          // Reset state if onReadOnlyChecked returns false\n          if (!this.options.onReadOnlyChecked(node, checked)) {\n            checkbox.checked = !checkbox.checked\n          }\n        }\n      })\n\n      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      listItem.dataset.checked = node.attrs.checked\n      checkbox.checked = node.attrs.checked\n\n      checkboxWrapper.append(checkbox, checkboxStyler)\n      listItem.append(checkboxWrapper, content)\n\n      Object.entries(HTMLAttributes).forEach(([key, value]) => {\n        listItem.setAttribute(key, value)\n      })\n\n      return {\n        dom: listItem,\n        contentDOM: content,\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          listItem.dataset.checked = updatedNode.attrs.checked\n          checkbox.checked = updatedNode.attrs.checked\n          updateA11Y(updatedNode)\n\n          return true\n        },\n      }\n    }\n  },\n\n  addInputRules() {\n    return [\n      wrappingInputRule({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: match => ({\n          checked: match[match.length - 1] === 'x',\n        }),\n      }),\n    ]\n  },\n})\n","import { mergeAttributes, Node } from '@tiptap/core'\n\nexport interface TaskListOptions {\n  /**\n   * The node type name for a task item.\n   * @default 'taskItem'\n   * @example 'myCustomTaskItem'\n   */\n  itemTypeName: string\n\n  /**\n   * The HTML attributes for a task list node.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    taskList: {\n      /**\n       * Toggle a task list\n       * @example editor.commands.toggleTaskList()\n       */\n      toggleTaskList: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */\nexport const TaskList = Node.create<TaskListOptions>({\n  name: 'taskList',\n\n  addOptions() {\n    return {\n      itemTypeName: 'taskItem',\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block list',\n\n  content() {\n    return `${this.options.itemTypeName}+`\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: `ul[data-type=\"${this.name}\"]`,\n        priority: 51,\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': this.name }), 0]\n  },\n\n  addCommands() {\n    return {\n      toggleTaskList:\n        () =>\n        ({ commands }) => {\n          return commands.toggleList(this.name, this.options.itemTypeName)\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-Shift-9': () => this.editor.commands.toggleTaskList(),\n    }\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}