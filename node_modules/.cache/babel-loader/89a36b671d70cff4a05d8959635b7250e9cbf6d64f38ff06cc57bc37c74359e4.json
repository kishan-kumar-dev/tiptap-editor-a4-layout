{"ast":null,"code":"// src/character-count/character-count.ts\nimport { Extension } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"@tiptap/pm/state\";\nvar CharacterCount = Extension.create({\n  name: \"characterCount\",\n  addOptions() {\n    return {\n      limit: null,\n      mode: \"textSize\",\n      textCounter: text => text.length,\n      wordCounter: text => text.split(\" \").filter(word => word !== \"\").length\n    };\n  },\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0\n    };\n  },\n  onBeforeCreate() {\n    this.storage.characters = options => {\n      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n      const mode = (options == null ? void 0 : options.mode) || this.options.mode;\n      if (mode === \"textSize\") {\n        const text = node.textBetween(0, node.content.size, void 0, \" \");\n        return this.options.textCounter(text);\n      }\n      return node.nodeSize;\n    };\n    this.storage.words = options => {\n      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;\n      const text = node.textBetween(0, node.content.size, \" \", \" \");\n      return this.options.wordCounter(text);\n    };\n  },\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false;\n    return [new Plugin({\n      key: new PluginKey(\"characterCount\"),\n      appendTransaction: (transactions, oldState, newState) => {\n        if (initialEvaluationDone) {\n          return;\n        }\n        const limit = this.options.limit;\n        if (limit === null || limit === void 0 || limit === 0) {\n          initialEvaluationDone = true;\n          return;\n        }\n        const initialContentSize = this.storage.characters({\n          node: newState.doc\n        });\n        if (initialContentSize > limit) {\n          const over = initialContentSize - limit;\n          const from = 0;\n          const to = over;\n          console.warn(`[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`);\n          const tr = newState.tr.deleteRange(from, to);\n          initialEvaluationDone = true;\n          return tr;\n        }\n        initialEvaluationDone = true;\n      },\n      filterTransaction: (transaction, state) => {\n        const limit = this.options.limit;\n        if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {\n          return true;\n        }\n        const oldSize = this.storage.characters({\n          node: state.doc\n        });\n        const newSize = this.storage.characters({\n          node: transaction.doc\n        });\n        if (newSize <= limit) {\n          return true;\n        }\n        if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n          return true;\n        }\n        if (oldSize > limit && newSize > limit && newSize > oldSize) {\n          return false;\n        }\n        const isPaste = transaction.getMeta(\"paste\");\n        if (!isPaste) {\n          return false;\n        }\n        const pos = transaction.selection.$head.pos;\n        const over = newSize - limit;\n        const from = pos - over;\n        const to = pos;\n        transaction.deleteRange(from, to);\n        const updatedSize = this.storage.characters({\n          node: transaction.doc\n        });\n        if (updatedSize > limit) {\n          return false;\n        }\n        return true;\n      }\n    })];\n  }\n});\n\n// src/drop-cursor/drop-cursor.ts\nimport { Extension as Extension2 } from \"@tiptap/core\";\nimport { dropCursor } from \"@tiptap/pm/dropcursor\";\nvar Dropcursor = Extension2.create({\n  name: \"dropCursor\",\n  addOptions() {\n    return {\n      color: \"currentColor\",\n      width: 1,\n      class: void 0\n    };\n  },\n  addProseMirrorPlugins() {\n    return [dropCursor(this.options)];\n  }\n});\n\n// src/focus/focus.ts\nimport { Extension as Extension3 } from \"@tiptap/core\";\nimport { Plugin as Plugin2, PluginKey as PluginKey2 } from \"@tiptap/pm/state\";\nimport { Decoration, DecorationSet } from \"@tiptap/pm/view\";\nvar Focus = Extension3.create({\n  name: \"focus\",\n  addOptions() {\n    return {\n      className: \"has-focus\",\n      mode: \"all\"\n    };\n  },\n  addProseMirrorPlugins() {\n    return [new Plugin2({\n      key: new PluginKey2(\"focus\"),\n      props: {\n        decorations: ({\n          doc,\n          selection\n        }) => {\n          const {\n            isEditable,\n            isFocused\n          } = this.editor;\n          const {\n            anchor\n          } = selection;\n          const decorations = [];\n          if (!isEditable || !isFocused) {\n            return DecorationSet.create(doc, []);\n          }\n          let maxLevels = 0;\n          if (this.options.mode === \"deepest\") {\n            doc.descendants((node, pos) => {\n              if (node.isText) {\n                return;\n              }\n              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n              if (!isCurrent) {\n                return false;\n              }\n              maxLevels += 1;\n            });\n          }\n          let currentLevel = 0;\n          doc.descendants((node, pos) => {\n            if (node.isText) {\n              return false;\n            }\n            const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;\n            if (!isCurrent) {\n              return false;\n            }\n            currentLevel += 1;\n            const outOfScope = this.options.mode === \"deepest\" && maxLevels - currentLevel > 0 || this.options.mode === \"shallowest\" && currentLevel > 1;\n            if (outOfScope) {\n              return this.options.mode === \"deepest\";\n            }\n            decorations.push(Decoration.node(pos, pos + node.nodeSize, {\n              class: this.options.className\n            }));\n          });\n          return DecorationSet.create(doc, decorations);\n        }\n      }\n    })];\n  }\n});\n\n// src/gap-cursor/gap-cursor.ts\nimport { callOrReturn, Extension as Extension4, getExtensionField } from \"@tiptap/core\";\nimport { gapCursor } from \"@tiptap/pm/gapcursor\";\nvar Gapcursor = Extension4.create({\n  name: \"gapCursor\",\n  addProseMirrorPlugins() {\n    return [gapCursor()];\n  },\n  extendNodeSchema(extension) {\n    var _a;\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    return {\n      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, \"allowGapCursor\", context))) != null ? _a : null\n    };\n  }\n});\n\n// src/placeholder/placeholder.ts\nimport { Extension as Extension5, isNodeEmpty } from \"@tiptap/core\";\nimport { Plugin as Plugin3, PluginKey as PluginKey3 } from \"@tiptap/pm/state\";\nimport { Decoration as Decoration2, DecorationSet as DecorationSet2 } from \"@tiptap/pm/view\";\nvar Placeholder = Extension5.create({\n  name: \"placeholder\",\n  addOptions() {\n    return {\n      emptyEditorClass: \"is-editor-empty\",\n      emptyNodeClass: \"is-empty\",\n      placeholder: \"Write something \\u2026\",\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false\n    };\n  },\n  addProseMirrorPlugins() {\n    return [new Plugin3({\n      key: new PluginKey3(\"placeholder\"),\n      props: {\n        decorations: ({\n          doc,\n          selection\n        }) => {\n          const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n          const {\n            anchor\n          } = selection;\n          const decorations = [];\n          if (!active) {\n            return null;\n          }\n          const isEmptyDoc = this.editor.isEmpty;\n          doc.descendants((node, pos) => {\n            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n            const isEmpty = !node.isLeaf && isNodeEmpty(node);\n            if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n              const classes = [this.options.emptyNodeClass];\n              if (isEmptyDoc) {\n                classes.push(this.options.emptyEditorClass);\n              }\n              const decoration = Decoration2.node(pos, pos + node.nodeSize, {\n                class: classes.join(\" \"),\n                \"data-placeholder\": typeof this.options.placeholder === \"function\" ? this.options.placeholder({\n                  editor: this.editor,\n                  node,\n                  pos,\n                  hasAnchor\n                }) : this.options.placeholder\n              });\n              decorations.push(decoration);\n            }\n            return this.options.includeChildren;\n          });\n          return DecorationSet2.create(doc, decorations);\n        }\n      }\n    })];\n  }\n});\n\n// src/selection/selection.ts\nimport { Extension as Extension6, isNodeSelection } from \"@tiptap/core\";\nimport { Plugin as Plugin4, PluginKey as PluginKey4 } from \"@tiptap/pm/state\";\nimport { Decoration as Decoration3, DecorationSet as DecorationSet3 } from \"@tiptap/pm/view\";\nvar Selection = Extension6.create({\n  name: \"selection\",\n  addOptions() {\n    return {\n      className: \"selection\"\n    };\n  },\n  addProseMirrorPlugins() {\n    const {\n      editor,\n      options\n    } = this;\n    return [new Plugin4({\n      key: new PluginKey4(\"selection\"),\n      props: {\n        decorations(state) {\n          if (state.selection.empty || editor.isFocused || !editor.isEditable || isNodeSelection(state.selection) || editor.view.dragging) {\n            return null;\n          }\n          return DecorationSet3.create(state.doc, [Decoration3.inline(state.selection.from, state.selection.to, {\n            class: options.className\n          })]);\n        }\n      }\n    })];\n  }\n});\n\n// src/trailing-node/trailing-node.ts\nimport { Extension as Extension7 } from \"@tiptap/core\";\nimport { Plugin as Plugin5, PluginKey as PluginKey5 } from \"@tiptap/pm/state\";\nfunction nodeEqualsType({\n  types,\n  node\n}) {\n  return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;\n}\nvar TrailingNode = Extension7.create({\n  name: \"trailingNode\",\n  addOptions() {\n    return {\n      node: \"paragraph\",\n      notAfter: []\n    };\n  },\n  addProseMirrorPlugins() {\n    const plugin = new PluginKey5(this.name);\n    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter(node => (this.options.notAfter || []).concat(this.options.node).includes(node.name));\n    return [new Plugin5({\n      key: plugin,\n      appendTransaction: (_, __, state) => {\n        const {\n          doc,\n          tr,\n          schema\n        } = state;\n        const shouldInsertNodeAtEnd = plugin.getState(state);\n        const endPosition = doc.content.size;\n        const type = schema.nodes[this.options.node];\n        if (!shouldInsertNodeAtEnd) {\n          return;\n        }\n        return tr.insert(endPosition, type.create());\n      },\n      state: {\n        init: (_, state) => {\n          const lastNode = state.tr.doc.lastChild;\n          return !nodeEqualsType({\n            node: lastNode,\n            types: disabledNodes\n          });\n        },\n        apply: (tr, value) => {\n          if (!tr.docChanged) {\n            return value;\n          }\n          const lastNode = tr.doc.lastChild;\n          return !nodeEqualsType({\n            node: lastNode,\n            types: disabledNodes\n          });\n        }\n      }\n    })];\n  }\n});\n\n// src/undo-redo/undo-redo.ts\nimport { Extension as Extension8 } from \"@tiptap/core\";\nimport { history, redo, undo } from \"@tiptap/pm/history\";\nvar UndoRedo = Extension8.create({\n  name: \"undoRedo\",\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500\n    };\n  },\n  addCommands() {\n    return {\n      undo: () => ({\n        state,\n        dispatch\n      }) => {\n        return undo(state, dispatch);\n      },\n      redo: () => ({\n        state,\n        dispatch\n      }) => {\n        return redo(state, dispatch);\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [history(this.options)];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-z\": () => this.editor.commands.undo(),\n      \"Shift-Mod-z\": () => this.editor.commands.redo(),\n      \"Mod-y\": () => this.editor.commands.redo(),\n      // Russian keyboard layouts\n      \"Mod-\\u044F\": () => this.editor.commands.undo(),\n      \"Shift-Mod-\\u044F\": () => this.editor.commands.redo()\n    };\n  }\n});\nexport { CharacterCount, Dropcursor, Focus, Gapcursor, Placeholder, Selection, TrailingNode, UndoRedo };","map":{"version":3,"names":["Extension","Plugin","PluginKey","CharacterCount","create","name","addOptions","limit","mode","textCounter","text","length","wordCounter","split","filter","word","addStorage","characters","words","onBeforeCreate","storage","options","node","editor","state","doc","textBetween","content","size","nodeSize","addProseMirrorPlugins","initialEvaluationDone","key","appendTransaction","transactions","oldState","newState","initialContentSize","over","from","to","console","warn","tr","deleteRange","filterTransaction","transaction","docChanged","oldSize","newSize","isPaste","getMeta","pos","selection","$head","updatedSize","Extension2","dropCursor","Dropcursor","color","width","class","Extension3","Plugin2","PluginKey2","Decoration","DecorationSet","Focus","className","props","decorations","isEditable","isFocused","anchor","maxLevels","descendants","isText","isCurrent","currentLevel","outOfScope","push","callOrReturn","Extension4","getExtensionField","gapCursor","Gapcursor","extendNodeSchema","extension","_a","context","allowGapCursor","Extension5","isNodeEmpty","Plugin3","PluginKey3","Decoration2","DecorationSet2","Placeholder","emptyEditorClass","emptyNodeClass","placeholder","showOnlyWhenEditable","showOnlyCurrent","includeChildren","active","isEmptyDoc","isEmpty","hasAnchor","isLeaf","classes","decoration","join","Extension6","isNodeSelection","Plugin4","PluginKey4","Decoration3","DecorationSet3","Selection","empty","view","dragging","inline","Extension7","Plugin5","PluginKey5","nodeEqualsType","types","Array","isArray","includes","type","TrailingNode","notAfter","plugin","disabledNodes","Object","entries","schema","nodes","map","value","concat","_","__","shouldInsertNodeAtEnd","getState","endPosition","insert","init","lastNode","lastChild","apply","Extension8","history","redo","undo","UndoRedo","depth","newGroupDelay","addCommands","dispatch","addKeyboardShortcuts","Mod-z","commands","Shift-Mod-z","Mod-y","Mod-я","Shift-Mod-я"],"sources":["C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extensions\\src\\character-count\\character-count.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extensions\\src\\drop-cursor\\drop-cursor.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extensions\\src\\focus\\focus.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extensions\\src\\gap-cursor\\gap-cursor.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extensions\\src\\placeholder\\placeholder.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extensions\\src\\selection\\selection.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extensions\\src\\trailing-node\\trailing-node.ts","C:\\Users\\01\\vettam-editor\\node_modules\\@tiptap\\extensions\\src\\undo-redo\\undo-redo.ts"],"sourcesContent":["import { Extension } from '@tiptap/core'\nimport type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nexport interface CharacterCountOptions {\n  /**\n   * The maximum number of characters that should be allowed. Defaults to `0`.\n   * @default null\n   * @example 180\n   */\n  limit: number | null | undefined\n  /**\n   * The mode by which the size is calculated. If set to `textSize`, the textContent of the document is used.\n   * If set to `nodeSize`, the nodeSize of the document is used.\n   * @default 'textSize'\n   * @example 'textSize'\n   */\n  mode: 'textSize' | 'nodeSize'\n  /**\n   * The text counter function to use. Defaults to a simple character count.\n   * @default (text) => text.length\n   * @example (text) => [...new Intl.Segmenter().segment(text)].length\n   */\n  textCounter: (text: string) => number\n  /**\n   * The word counter function to use. Defaults to a simple word count.\n   * @default (text) => text.split(' ').filter(word => word !== '').length\n   * @example (text) => text.split(/\\s+/).filter(word => word !== '').length\n   */\n  wordCounter: (text: string) => number\n}\n\nexport interface CharacterCountStorage {\n  /**\n   * Get the number of characters for the current document.\n   * @param options The options for the character count. (optional)\n   * @param options.node The node to get the characters from. Defaults to the current document.\n   * @param options.mode The mode by which the size is calculated. If set to `textSize`, the textContent of the document is used.\n   */\n  characters: (options?: { node?: ProseMirrorNode; mode?: 'textSize' | 'nodeSize' }) => number\n\n  /**\n   * Get the number of words for the current document.\n   * @param options The options for the character count. (optional)\n   * @param options.node The node to get the words from. Defaults to the current document.\n   */\n  words: (options?: { node?: ProseMirrorNode }) => number\n}\n\ndeclare module '@tiptap/core' {\n  interface Storage {\n    characterCount: CharacterCountStorage\n  }\n}\n\n/**\n * This extension allows you to count the characters and words of your document.\n * @see https://tiptap.dev/api/extensions/character-count\n */\nexport const CharacterCount = Extension.create<CharacterCountOptions, CharacterCountStorage>({\n  name: 'characterCount',\n\n  addOptions() {\n    return {\n      limit: null,\n      mode: 'textSize',\n      textCounter: text => text.length,\n      wordCounter: text => text.split(' ').filter(word => word !== '').length,\n    }\n  },\n\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0,\n    }\n  },\n\n  onBeforeCreate() {\n    this.storage.characters = options => {\n      const node = options?.node || this.editor.state.doc\n      const mode = options?.mode || this.options.mode\n\n      if (mode === 'textSize') {\n        const text = node.textBetween(0, node.content.size, undefined, ' ')\n\n        return this.options.textCounter(text)\n      }\n\n      return node.nodeSize\n    }\n\n    this.storage.words = options => {\n      const node = options?.node || this.editor.state.doc\n      const text = node.textBetween(0, node.content.size, ' ', ' ')\n\n      return this.options.wordCounter(text)\n    }\n  },\n\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false\n\n    return [\n      new Plugin({\n        key: new PluginKey('characterCount'),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (initialEvaluationDone) {\n            return\n          }\n\n          const limit = this.options.limit\n\n          if (limit === null || limit === undefined || limit === 0) {\n            initialEvaluationDone = true\n            return\n          }\n\n          const initialContentSize = this.storage.characters({ node: newState.doc })\n\n          if (initialContentSize > limit) {\n            const over = initialContentSize - limit\n            const from = 0\n            const to = over\n\n            console.warn(\n              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`,\n            )\n            const tr = newState.tr.deleteRange(from, to)\n\n            initialEvaluationDone = true\n            return tr\n          }\n\n          initialEvaluationDone = true\n        },\n        filterTransaction: (transaction, state) => {\n          const limit = this.options.limit\n\n          // Nothing has changed or no limit is defined. Ignore it.\n          if (!transaction.docChanged || limit === 0 || limit === null || limit === undefined) {\n            return true\n          }\n\n          const oldSize = this.storage.characters({ node: state.doc })\n          const newSize = this.storage.characters({ node: transaction.doc })\n\n          // Everything is in the limit. Good.\n          if (newSize <= limit) {\n            return true\n          }\n\n          // The limit has already been exceeded but will be reduced.\n          if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n            return true\n          }\n\n          // The limit has already been exceeded and will be increased further.\n          if (oldSize > limit && newSize > limit && newSize > oldSize) {\n            return false\n          }\n\n          const isPaste = transaction.getMeta('paste')\n\n          // Block all exceeding transactions that were not pasted.\n          if (!isPaste) {\n            return false\n          }\n\n          // For pasted content, we try to remove the exceeding content.\n          const pos = transaction.selection.$head.pos\n          const over = newSize - limit\n          const from = pos - over\n          const to = pos\n\n          // It’s probably a bad idea to mutate transactions within `filterTransaction`\n          // but for now this is working fine.\n          transaction.deleteRange(from, to)\n\n          // In some situations, the limit will continue to be exceeded after trimming.\n          // This happens e.g. when truncating within a complex node (e.g. table)\n          // and ProseMirror has to close this node again.\n          // If this is the case, we prevent the transaction completely.\n          const updatedSize = this.storage.characters({ node: transaction.doc })\n\n          if (updatedSize > limit) {\n            return false\n          }\n\n          return true\n        },\n      }),\n    ]\n  },\n})\n","import { Extension } from '@tiptap/core'\nimport { dropCursor } from '@tiptap/pm/dropcursor'\n\nexport interface DropcursorOptions {\n  /**\n   * The color of the drop cursor\n   * @default 'currentColor'\n   * @example 'red'\n   */\n  color: string | undefined\n\n  /**\n   * The width of the drop cursor\n   * @default 1\n   * @example 2\n   */\n  width: number | undefined\n\n  /**\n   * The class of the drop cursor\n   * @default undefined\n   * @example 'drop-cursor'\n   */\n  class: string | undefined\n}\n\n/**\n * This extension allows you to add a drop cursor to your editor.\n * A drop cursor is a line that appears when you drag and drop content\n * in-between nodes.\n * @see https://tiptap.dev/api/extensions/dropcursor\n */\nexport const Dropcursor = Extension.create<DropcursorOptions>({\n  name: 'dropCursor',\n\n  addOptions() {\n    return {\n      color: 'currentColor',\n      width: 1,\n      class: undefined,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [dropCursor(this.options)]\n  },\n})\n","import { Extension } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\nexport interface FocusOptions {\n  /**\n   * The class name that should be added to the focused node.\n   * @default 'has-focus'\n   * @example 'is-focused'\n   */\n  className: string\n\n  /**\n   * The mode by which the focused node is determined.\n   * - All: All nodes are marked as focused.\n   * - Deepest: Only the deepest node is marked as focused.\n   * - Shallowest: Only the shallowest node is marked as focused.\n   *\n   * @default 'all'\n   * @example 'deepest'\n   * @example 'shallowest'\n   */\n  mode: 'all' | 'deepest' | 'shallowest'\n}\n\n/**\n * This extension allows you to add a class to the focused node.\n * @see https://www.tiptap.dev/api/extensions/focus\n */\nexport const Focus = Extension.create<FocusOptions>({\n  name: 'focus',\n\n  addOptions() {\n    return {\n      className: 'has-focus',\n      mode: 'all',\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('focus'),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const { isEditable, isFocused } = this.editor\n            const { anchor } = selection\n            const decorations: Decoration[] = []\n\n            if (!isEditable || !isFocused) {\n              return DecorationSet.create(doc, [])\n            }\n\n            // Maximum Levels\n            let maxLevels = 0\n\n            if (this.options.mode === 'deepest') {\n              doc.descendants((node, pos) => {\n                if (node.isText) {\n                  return\n                }\n\n                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1\n\n                if (!isCurrent) {\n                  return false\n                }\n\n                maxLevels += 1\n              })\n            }\n\n            // Loop through current\n            let currentLevel = 0\n\n            doc.descendants((node, pos) => {\n              if (node.isText) {\n                return false\n              }\n\n              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1\n\n              if (!isCurrent) {\n                return false\n              }\n\n              currentLevel += 1\n\n              const outOfScope =\n                (this.options.mode === 'deepest' && maxLevels - currentLevel > 0) ||\n                (this.options.mode === 'shallowest' && currentLevel > 1)\n\n              if (outOfScope) {\n                return this.options.mode === 'deepest'\n              }\n\n              decorations.push(\n                Decoration.node(pos, pos + node.nodeSize, {\n                  class: this.options.className,\n                }),\n              )\n            })\n\n            return DecorationSet.create(doc, decorations)\n          },\n        },\n      }),\n    ]\n  },\n})\n","import type { ParentConfig } from '@tiptap/core'\nimport { callOrReturn, Extension, getExtensionField } from '@tiptap/core'\nimport { gapCursor } from '@tiptap/pm/gapcursor'\n\ndeclare module '@tiptap/core' {\n  interface NodeConfig<Options, Storage> {\n    /**\n     * A function to determine whether the gap cursor is allowed at the current position. Must return `true` or `false`.\n     * @default null\n     */\n    allowGapCursor?:\n      | boolean\n      | null\n      | ((this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options>>['allowGapCursor']\n        }) => boolean | null)\n  }\n}\n\n/**\n * This extension allows you to add a gap cursor to your editor.\n * A gap cursor is a cursor that appears when you click on a place\n * where no content is present, for example inbetween nodes.\n * @see https://tiptap.dev/api/extensions/gapcursor\n */\nexport const Gapcursor = Extension.create({\n  name: 'gapCursor',\n\n  addProseMirrorPlugins() {\n    return [gapCursor()]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      allowGapCursor: callOrReturn(getExtensionField(extension, 'allowGapCursor', context)) ?? null,\n    }\n  },\n})\n","import type { Editor } from '@tiptap/core'\nimport { Extension, isNodeEmpty } from '@tiptap/core'\nimport type { Node as ProsemirrorNode } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\nexport interface PlaceholderOptions {\n  /**\n   * **The class name for the empty editor**\n   * @default 'is-editor-empty'\n   */\n  emptyEditorClass: string\n\n  /**\n   * **The class name for empty nodes**\n   * @default 'is-empty'\n   */\n  emptyNodeClass: string\n\n  /**\n   * **The placeholder content**\n   *\n   * You can use a function to return a dynamic placeholder or a string.\n   * @default 'Write something …'\n   */\n  placeholder:\n    | ((PlaceholderProps: { editor: Editor; node: ProsemirrorNode; pos: number; hasAnchor: boolean }) => string)\n    | string\n\n  /**\n   * **Checks if the placeholder should be only shown when the editor is editable.**\n   *\n   * If true, the placeholder will only be shown when the editor is editable.\n   * If false, the placeholder will always be shown.\n   * @default true\n   */\n  showOnlyWhenEditable: boolean\n\n  /**\n   * **Checks if the placeholder should be only shown when the current node is empty.**\n   *\n   * If true, the placeholder will only be shown when the current node is empty.\n   * If false, the placeholder will be shown when any node is empty.\n   * @default true\n   */\n  showOnlyCurrent: boolean\n\n  /**\n   * **Controls if the placeholder should be shown for all descendents.**\n   *\n   * If true, the placeholder will be shown for all descendents.\n   * If false, the placeholder will only be shown for the current node.\n   * @default false\n   */\n  includeChildren: boolean\n}\n\n/**\n * This extension allows you to add a placeholder to your editor.\n * A placeholder is a text that appears when the editor or a node is empty.\n * @see https://www.tiptap.dev/api/extensions/placeholder\n */\nexport const Placeholder = Extension.create<PlaceholderOptions>({\n  name: 'placeholder',\n\n  addOptions() {\n    return {\n      emptyEditorClass: 'is-editor-empty',\n      emptyNodeClass: 'is-empty',\n      placeholder: 'Write something …',\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('placeholder'),\n        props: {\n          decorations: ({ doc, selection }) => {\n            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable\n            const { anchor } = selection\n            const decorations: Decoration[] = []\n\n            if (!active) {\n              return null\n            }\n\n            const isEmptyDoc = this.editor.isEmpty\n\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize\n              const isEmpty = !node.isLeaf && isNodeEmpty(node)\n\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass]\n\n                if (isEmptyDoc) {\n                  classes.push(this.options.emptyEditorClass)\n                }\n\n                const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(' '),\n                  'data-placeholder':\n                    typeof this.options.placeholder === 'function'\n                      ? this.options.placeholder({\n                          editor: this.editor,\n                          node,\n                          pos,\n                          hasAnchor,\n                        })\n                      : this.options.placeholder,\n                })\n\n                decorations.push(decoration)\n              }\n\n              return this.options.includeChildren\n            })\n\n            return DecorationSet.create(doc, decorations)\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Extension, isNodeSelection } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\n\nexport type SelectionOptions = {\n  /**\n   * The class name that should be added to the selected text.\n   * @default 'selection'\n   * @example 'is-selected'\n   */\n  className: string\n}\n\n/**\n * This extension allows you to add a class to the selected text.\n * @see https://www.tiptap.dev/api/extensions/selection\n */\nexport const Selection = Extension.create({\n  name: 'selection',\n\n  addOptions() {\n    return {\n      className: 'selection',\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const { editor, options } = this\n\n    return [\n      new Plugin({\n        key: new PluginKey('selection'),\n        props: {\n          decorations(state) {\n            if (\n              state.selection.empty ||\n              editor.isFocused ||\n              !editor.isEditable ||\n              isNodeSelection(state.selection) ||\n              editor.view.dragging\n            ) {\n              return null\n            }\n\n            return DecorationSet.create(state.doc, [\n              Decoration.inline(state.selection.from, state.selection.to, {\n                class: options.className,\n              }),\n            ])\n          },\n        },\n      }),\n    ]\n  },\n})\n\nexport default Selection\n","import { Extension } from '@tiptap/core'\nimport type { Node, NodeType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nfunction nodeEqualsType({ types, node }: { types: NodeType | NodeType[]; node: Node | null | undefined }) {\n  return (node && Array.isArray(types) && types.includes(node.type)) || node?.type === types\n}\n\n/**\n * Extension based on:\n * - https://github.com/ueberdosis/tiptap/blob/v1/packages/tiptap-extensions/src/extensions/TrailingNode.js\n * - https://github.com/remirror/remirror/blob/e0f1bec4a1e8073ce8f5500d62193e52321155b9/packages/prosemirror-trailing-node/src/trailing-node-plugin.ts\n */\n\nexport interface TrailingNodeOptions {\n  /**\n   * The node type that should be inserted at the end of the document.\n   * @note the node will always be added to the `notAfter` lists to\n   * prevent an infinite loop.\n   * @default 'paragraph'\n   */\n  node: string\n  /**\n   * The node types after which the trailing node should not be inserted.\n   * @default ['paragraph']\n   */\n  notAfter?: string | string[]\n}\n\n/**\n * This extension allows you to add an extra node at the end of the document.\n * @see https://www.tiptap.dev/api/extensions/trailing-node\n */\nexport const TrailingNode = Extension.create<TrailingNodeOptions>({\n  name: 'trailingNode',\n\n  addOptions() {\n    return {\n      node: 'paragraph',\n      notAfter: [],\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const plugin = new PluginKey(this.name)\n    const disabledNodes = Object.entries(this.editor.schema.nodes)\n      .map(([, value]) => value)\n      .filter(node => (this.options.notAfter || []).concat(this.options.node).includes(node.name))\n\n    return [\n      new Plugin({\n        key: plugin,\n        appendTransaction: (_, __, state) => {\n          const { doc, tr, schema } = state\n          const shouldInsertNodeAtEnd = plugin.getState(state)\n          const endPosition = doc.content.size\n          const type = schema.nodes[this.options.node]\n\n          if (!shouldInsertNodeAtEnd) {\n            return\n          }\n\n          return tr.insert(endPosition, type.create())\n        },\n        state: {\n          init: (_, state) => {\n            const lastNode = state.tr.doc.lastChild\n\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes })\n          },\n          apply: (tr, value) => {\n            if (!tr.docChanged) {\n              return value\n            }\n\n            const lastNode = tr.doc.lastChild\n\n            return !nodeEqualsType({ node: lastNode, types: disabledNodes })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Extension } from '@tiptap/core'\nimport { history, redo, undo } from '@tiptap/pm/history'\n\nexport interface UndoRedoOptions {\n  /**\n   * The amount of history events that are collected before the oldest events are discarded.\n   * @default 100\n   * @example 50\n   */\n  depth: number\n\n  /**\n   * The delay (in milliseconds) between changes after which a new group should be started.\n   * @default 500\n   * @example 1000\n   */\n  newGroupDelay: number\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoRedo: {\n      /**\n       * Undo recent changes\n       * @example editor.commands.undo()\n       */\n      undo: () => ReturnType\n      /**\n       * Reapply reverted changes\n       * @example editor.commands.redo()\n       */\n      redo: () => ReturnType\n    }\n  }\n}\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/undo-redo\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `undo-redo` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nexport const UndoRedo = Extension.create<UndoRedoOptions>({\n  name: 'undoRedo',\n\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500,\n    }\n  },\n\n  addCommands() {\n    return {\n      undo:\n        () =>\n        ({ state, dispatch }) => {\n          return undo(state, dispatch)\n        },\n      redo:\n        () =>\n        ({ state, dispatch }) => {\n          return redo(state, dispatch)\n        },\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [history(this.options)]\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      'Mod-z': () => this.editor.commands.undo(),\n      'Shift-Mod-z': () => this.editor.commands.redo(),\n      'Mod-y': () => this.editor.commands.redo(),\n\n      // Russian keyboard layouts\n      'Mod-я': () => this.editor.commands.undo(),\n      'Shift-Mod-я': () => this.editor.commands.redo(),\n    }\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}